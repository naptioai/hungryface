<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Baby Monitor – Receiver</title>
  <link rel="icon" href="data:,">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>

  <link rel="stylesheet" href="/hungryface/webrtc/receiver/shared/sidebar.css" />

  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; height: 100%;
      background: #000; color: #fff;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif;
      overflow: hidden;
    }
    #stage {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      width: 100dvw; height: 100dvh;
      width: 100svw; height: 100svh;
      z-index: 1; background: #000;
    }
    #stage > video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; background: #000; }
    #stage > canvas { position: absolute; z-index: 2; pointer-events: none; background: transparent; display: none; }

    .btn {
      padding: 12px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.6);
      background: transparent; color: #fff; font-size: 16px; font-weight: 600;
      cursor: pointer; box-shadow: none; text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    }
    .btn:active { transform: scale(0.99); }
    .btn[disabled] { opacity: 0.6; cursor: default; }

    .spinner {
      display: inline-block; width: 12px; height: 12px;
      border: 2px solid rgba(255,255,255,0.35);
      border-top-color: #fff; border-radius: 50%;
      margin-right: 8px; animation: spin 1s linear infinite; vertical-align: -1px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #controls {
      position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%);
      display: flex; align-items: center; gap: 12px; z-index: 6;
      flex-wrap: wrap; justify-content: center;
    }
    #enableAudioBtn, #disableAudioBtn { display: none; }

    .overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; pointer-events: none; z-index: 5; }
    .status {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #ddd; font-size: 14px; padding: 10px 14px; border-radius: 12px;
      text-align: center; white-space: pre-line; max-width: 90vw;
    }
    .overlay.hidden { display: none; }

    /* Movement panel */
    #movePanel {
      position: fixed;
      right: 16px;
    
      /* NEW: pin to both top & bottom so header can’t go off-screen */
      top: 12px;                 /* was not set */
      bottom: 80px;              /* unchanged gap above bottom controls */
    
      z-index: 7;
      width: min(380px, 92vw);
    
      /* NEW: let top/bottom define the height; avoid vh on iOS */
      max-height: none;
    
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    
      background: rgba(20,20,20,0.9);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      backdrop-filter: blur(6px);
      padding: 12px 12px 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
    }
    
    /* SAFE-AREA support for iPhone/iPad (overrides the values above when available) */
    @supports (padding: env(safe-area-inset-top)) {
      #movePanel {
        right: calc(16px + env(safe-area-inset-right));
        top:   calc(12px + env(safe-area-inset-top));
        bottom: calc(80px + env(safe-area-inset-bottom));
        /* keep the same visual width while respecting left/right notches */
        width: min(380px, calc(100svw - (32px + env(safe-area-inset-left) + env(safe-area-inset-right))));
      }
    
      /* Also lift the bottom controls above the home indicator */
      #controls {
        bottom: 16px; /* fallback */
        bottom: calc(16px + env(safe-area-inset-bottom));
      }
    }

    #movePanel.hidden { display: none; }
    #movePanel header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 6px; }
    #movePanel h3 { margin: 0; font-size: 14px; font-weight: 700; color: #eee; }
    #movePanel .close { appearance: none; border: none; background: transparent; color: #aaa; font-size: 20px; line-height: 1; cursor: pointer; padding: 2px 6px; }
    #movePanel .row { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 10px; margin: 8px 0; }
    #movePanel label { font-size: 12px; color: #ccc; white-space: nowrap; }
    #movePanel input[type="range"] { width: 100%; }
    #movePanel output { font-variant-numeric: tabular-nums; font-size: 12px; color: #ddd; min-width: 64px; text-align: right; }
    #movePanel .muted { color: #aaa; font-size: 12px; }
    #movePanel .stateRow { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; margin-bottom: 4px; border: 1px dashed rgba(255,255,255,0.15); border-radius: 10px; }
    #movePanel .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; font-weight: 600; border: 1px solid rgba(255,255,255,0.2); }
    #movePanel .pill.moving  { background: #4a2a00; color: #ffcc80; border-color: #ffa64d; }
    #movePanel .pill.still   { background: #111;   color: #ddd;     border-color: rgba(255,255,255,0.25); }
    #movePanel .groupTitle { margin: 10px 0 2px; font-size: 12px; color: #bbb; font-weight: 700; }
    #movePanel .row3 { display: grid; grid-template-columns: auto 1fr auto; gap: 10px; }

    /* Center controls rows with buttons */
    #calActions,
    #bottomActions {
      display: flex; gap: 8px; justify-content: center; margin-top: 6px; align-items: center;
    }
    .small { padding: 8px 10px; font-size: 13px; border-radius: 10px; }

    /* Calibration bits */
    #calProgRow { display: none; }
    #calStatus.ok { color: #b7f0b7; }
    #calStatus.warn { color: #ffd27a; }
    #calStatus.err { color: #ff9b9b; }
    #calStatus.running { color: #ff4d4f; font-weight: 700; } /* RED while calibrating */
    progress { width: 100%; height: 6px; border-radius: 999px; overflow: hidden; }

    /* === Help drawer === */
    .help-backdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5);
      z-index: 15; opacity: 0; pointer-events: none; transition: opacity .2s ease;
    }
    .help-backdrop.show { opacity: 1; pointer-events: auto; }
    .help-sheet {
      position: fixed; right: 0; top: 0; height: 100svh; width: min(92vw, 420px);
      background: #121212; color: #f3f3f3; border-left: 1px solid rgba(255,255,255,0.12);
      box-shadow: -12px 0 32px rgba(0,0,0,0.6); z-index: 20;
      transform: translateX(100%); transition: transform .24s cubic-bezier(.2,.8,.2,1);
      display: flex; flex-direction: column;
    }
    .help-sheet.show { transform: translateX(0); }
    .help-header { position: sticky; top: 0; z-index: 1; background: rgba(18,18,18,0.96); backdrop-filter: blur(6px); display: flex; align-items: center; justify-content: space-between; padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.08); }
    .help-header h3 { margin: 0; font-size: 16px; font-weight: 700; color: #fff; }
    .help-header .close { appearance: none; border: none; background: transparent; color: #aaa; font-size: 22px; cursor: pointer; padding: 2px 6px; }
    .help-body { padding: 10px 12px 16px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
    .help-toc { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0 12px; padding-bottom: 8px; border-bottom: 1px dashed rgba(255,255,255,0.15); }
    .help-toc a { font-size: 12px; color: #ddd; text-decoration: none; border: 1px solid rgba(255,255,255,0.18); padding: 6px 8px; border-radius: 999px; }
    .help-toc a:active { transform: scale(0.98); }
    .help-section { margin: 14px 0; }
    .help-section h4 { margin: 0 0 6px; font-size: 14px; color: #fff; }
    .help-section p, .help-section li, .help-section td, .help-section th { font-size: 13px; color: #ddd; line-height: 1.45; }
    .help-kv { width: 100%; border-collapse: collapse; margin-top: 6px; }
    .help-kv th, .help-kv td { border: 1px solid rgba(255,255,255,0.12); padding: 8px; vertical-align: top; }
    .help-kv th { background: rgba(255,255,255,0.06); font-weight: 700; color: #eee; white-space: nowrap; }
    .help-kv td { color: #ddd; }
    .help-callout { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 10px; }
    details.learn-more { border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 10px; background: rgba(255,255,255,0.04); }
    details.learn-more > summary { cursor: pointer; list-style: none; font-weight: 700; color: #fff; }
    details.learn-more > summary::-webkit-details-marker { display: none; }
    details.learn-more[open] { background: rgba(255,255,255,0.06); }
    .codeblock { background: #0e0e0e; border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: #d7eaff; font-size: 12px; overflow-x: auto; }

    /* header actions container in settings */
    #movePanel header { gap: 8px; }
    #movePanel header .headerActions { display: flex; gap: 8px; align-items: center; }
  </style>
</head>
<body>
  <!-- shared sidebar -->
  <script type="module">
    (async () => {
      try {
        const res = await fetch('/hungryface/webrtc/receiver/shared/sidebar.html', { cache: 'no-cache' });
        const html = await res.text();
        const wrap = document.createElement('div');
        wrap.innerHTML = html.trim();
        document.body.prepend(...wrap.childNodes);

        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = '/hungryface/webrtc/receiver/shared/sidebar.js';
          s.onload = resolve; s.onerror = reject;
          document.body.appendChild(s);
        });
      } catch (err) { console.error('[Sidebar] failed to load shared assets:', err); }
    })();
  </script>

  <!-- NEW: inject the Help side-sheet HTML -->
  <script type="module" src="/hungryface/webrtc/receiver/motion/help-sheet.js"></script>
  <div id="controls">
    <button id="enableAudioBtn" class="btn" type="button">Enable audio</button>
    <button id="disableAudioBtn" class="btn" type="button">Disable audio</button>
    <button id="fsBtn" class="btn" type="button">Fullscreen</button>
    <button id="calQuickBtn" class="btn" type="button">Calibration</button>
    <button id="moveBtn" class="btn" type="button">Movement settings</button>
  </div>

  <section id="movePanel" class="hidden" aria-label="Movement settings">
    <header>
      <h3>Movement detection</h3>
      <div class="headerActions">
        <button id="helpBtn" class="btn small" type="button" title="Open Help">Help</button>
        <button id="moveClose" class="close" title="Close">×</button>
      </div>
    </header>

    <div class="stateRow" id="stateRow">
      <div class="muted"><span id="moveStateTxt" class="pill still">STILL</span></div>
      <div class="muted">
        Scores: EMA <strong id="emaScoreTxt">0.000</strong> · INT <strong id="intScoreTxt">0.000</strong> · DRIFT <strong id="driftScoreTxt">0.000</strong>
      </div>
    </div>

    <!-- Calibration at the top -->
    <div class="groupTitle">Calibration</div>
    <div class="row">
      <label for="calSecs">Duration</label>
      <input id="calSecs" type="range" min="5" max="60" step="1">
      <output id="calSecsOut">15 s</output>
    </div>
    <div class="checkRow">
      <label><input id="calLive" type="checkbox"> Apply thresholds while running</label>
    </div>
    <div class="row">
      <label>Auto-calibrate</label>
      <button id="calStart" class="btn small" type="button">Start</button>
      <output id="calStatus" class="muted">Idle</output>
    </div>
    <div class="row" id="calProgRow">
      <label>Progress</label>
      <progress id="calProg" max="1" value="0"></progress>
      <output id="calTime">15s</output>
    </div>
    <div id="calStats" style="display:none">
      <div class="row"><label>Median</label><span></span><output id="calMedian">—</output></div>
      <div class="row"><label>95th pct</label><span></span><output id="calP95">—</output></div>
      <div class="row"><label>Samples</label><span></span><output id="calN">0</output></div>
    </div>

    <!-- Confidence gates -->
    <div class="groupTitle">Confidence gates</div>
    <div class="row">
      <label for="visMin">Visibility min</label>
      <input id="visMin" type="range" min="0.00" max="0.99" step="0.01">
      <output id="visOut">0.80</output>
    </div>
    <div class="row">
      <label for="presMin">Presence min</label>
      <input id="presMin" type="range" min="0.00" max="0.99" step="0.01">
      <output id="presOut">0.90</output>
    </div>

    <!-- EMA -->
    <div class="groupTitle">Short-term (EMA)</div>
    <div class="checkRow"><label><input id="useEma" type="checkbox"> Enable EMA detector</label></div>
    <div class="row"><label for="ema">EMA α</label><input id="ema" type="range" min="0.01" max="0.90" step="0.01"><output id="emaOut">0.20</output></div>
    <div class="row"><label for="onTh">EMA ON</label><input id="onTh" type="range" min="0.005" max="0.500" step="0.005"><output id="onOut">0.060</output></div>
    <div class="row"><label for="offTh">EMA OFF</label><input id="offTh" type="range" min="0.005" max="0.500" step="0.005"><output id="offOut">0.030</output></div>

    <!-- Integrator -->
    <div class="groupTitle">Long-term (Integrator)</div>
    <div class="checkRow"><label><input id="useInt" type="checkbox"> Enable Integrator</label></div>
    <div class="row"><label for="tau">INT τ (s)</label><input id="tau" type="range" min="0.5" max="8.0" step="0.1"><output id="tauOut">3.0 s</output></div>
    <div class="row"><label for="intOn">INT ON</label><input id="intOn" type="range" min="0.005" max="2.000" step="0.005"><output id="intOnOut">0.035</output></div>
    <div class="row"><label for="intOff">INT OFF</label><input id="intOff" type="range" min="0.005" max="2.000" step="0.005"><output id="intOffOut">0.020</output></div>

    <!-- Baseline drift -->
    <div class="groupTitle">Baseline drift</div>
    <div class="checkRow">
      <label><input id="useDrift" type="checkbox"> Enable Drift detector</label>
    </div>
    <div class="checkRow">
      <label><input id="driftTorsoRel" type="checkbox"> Torso-relative baseline (reduces camera shake)</label>
    </div>
    <!-- Baseline overlay toggle -->
    <div class="checkRow">
      <label><input id="showBaseline" type="checkbox"> Show baseline overlay (ghost + vectors)</label>
    </div>
    <div class="row"><label for="driftTau">Baseline τ (s)</label><input id="driftTau" type="range" min="0.5" max="8.0" step="0.1"><output id="driftTauOut">2.5 s</output></div>
    <div class="row"><label for="driftOn">DRIFT ON</label><input id="driftOn" type="range" min="0.010" max="1.000" step="0.005"><output id="driftOnOut">0.080</output></div>
    <div class="row"><label for="driftOff">DRIFT OFF</label><input id="driftOff" type="range" min="0.005" max="1.000" step="0.005"><output id="driftOffOut">0.050</output></div>

    <!-- Centered baseline/reset buttons; widths matched to Start -->
    <div id="calActions">
      <button id="driftReset" class="btn small" type="button">Reset baseline</button>
    </div>

    <div id="bottomActions">
      <button id="moveReset" class="btn small" type="button" title="Restore all movement settings to factory defaults and clear calibration">
        Reset all defaults
      </button>
    </div>
  </section>

  <!-- Help side sheet HTML removed; now injected by help-sheet.js -->

  <div id="stage">
    <video id="remote" autoplay playsinline></video>
    <canvas id="poseCanvas"></canvas>
  </div>

  <div id="overlay" class="overlay"><div id="status" class="status">Idle</div></div>

  <!-- ⬇️ PSK bootstrap (viewer); resolves room from query/Settings and installs shim -->
  <script type="module">
    import { installPskShim } from '/hungryface/webrtc/shared/psk/psk-ws-shim.js';
    import { requirePskOrRedirect } from '/hungryface/webrtc/shared/psk/require-psk.js';

    const qs = new URLSearchParams(location.search);
    const qsRoom   = (qs.get('room') || '').trim();
    const stored   = (localStorage.getItem('bm_receiver_room') || '').trim();
    const lastRoom = (localStorage.getItem('naptio:lastRoom') || '').trim();

    const preferRoom = qsRoom || stored || lastRoom || '';

    const env = await requirePskOrRedirect({
      intent: 'viewer',
      pairRoute: '/hungryface/webrtc/pairpsk/',
      preferRoom,
      fallbackRoom: 'Baby',
    });

    // Expose env + safe re-install hook (same API shape as sender)
    window.__pskEnv = env;
    window.__installPskForRoom = (room) => {
      try { window.__pskUndo?.(); } catch {}
      window.__pskUndo = installPskShim({ room });
      console.log('[PSK][receiver-fence] shim installed for room:', room);
      try {
        localStorage.setItem('bm_receiver_room', room);
        localStorage.setItem('naptio:lastRoom', room);
      } catch {}
    };

    if (!env.redirected) {
      const resolvedRoom = qsRoom || stored || lastRoom || env.room || 'Baby';
      window.__installPskForRoom(resolvedRoom);
      window.__pskRoom = resolvedRoom;
    }
  </script>
  
  <script type="module">
    import { DrawingUtils, PoseLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";
    import { ReceiverCore } from "/hungryface/webrtc/receiver/shared/receiver-core.js";
    import {initAlertsUI, beginAlert, finishAlert, AlertTypes, showAlertBanner} from "/hungryface/webrtc/receiver/shared/alerts/index.js";

    /* --------- tiny safe addEventListener helper --------- */
    const on = (el, ev, fn, opts) => { if (el && el.addEventListener) el.addEventListener(ev, fn, opts); };

    /* ---------- Constants ---------- */
    const WS_ENDPOINT = "wss://signaling-server-f5gu.onrender.com/ws";
    const room = window.__pskRoom || "Baby";
    const STATUS_HIDE_AFTER_CONNECTED_MS = 10000;

    // live-pose gating
    const LIVE_POSE_TIMEOUT_MS = 2000; // consider "live" if a landmark arrived in the last 2s
    let lastPoseTs = 0;

    const MOVE_DEFAULTS = {
      VIS_MIN: 0.80,
      PRES_MIN: 0.90,
      EMA_ALPHA: 0.20,
      ON:  0.06,
      OFF: 0.03,
      OFF_HOLD_MS: 700,
      MIN_SCALE: 0.02,
      INT_TAU: 3.0,
      INT_ON:  0.035,
      INT_OFF: 0.020,
      DRIFT_TAU: 2.5,
      DRIFT_ON:  0.080,
      DRIFT_OFF: 0.050,
      DRIFT_TORSO_REL: true,
      USE_EMA: true,
      USE_INT: true,
      USE_DRIFT: true,
      CAL_SECS: 15,
      CAL_LIVE: true,
      SHOW_BASELINE: false
    };
    const LS_KEY = 'naptio-move-config-v6';
    const MOVE = { ...MOVE_DEFAULTS, ...loadMoveConfig() };

    const TASKS_URL = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";
    const WASM_DIR = TASKS_URL + "/wasm";
    const POSE_MODEL_URL =
      "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";
    const HAVE_CURRENT_DATA = 2;

    /* ---------- DOM ---------- */
    const stage = document.getElementById('stage');
    const remoteVideo = document.getElementById('remote');
    const poseCanvas = document.getElementById('poseCanvas');
    const poseCtx = poseCanvas.getContext('2d', { alpha: true });

    const fsBtn = document.getElementById('fsBtn');
    const enableAudioBtn = document.getElementById('enableAudioBtn');
    const disableAudioBtn = document.getElementById('disableAudioBtn');
    const overlay = document.getElementById('overlay');
    const statusEl = document.getElementById('status');

    const calQuickBtn = document.getElementById('calQuickBtn');
    let calQuickBtnActive = false;

    const moveBtn    = document.getElementById('moveBtn');
    const movePanel  = document.getElementById('movePanel');
    const moveClose  = document.getElementById('moveClose');
    const moveReset  = document.getElementById('moveReset');

    const stateRow      = document.getElementById('stateRow');
    const moveStateTxt  = document.getElementById('moveStateTxt');
    const emaScoreTxt   = document.getElementById('emaScoreTxt');
    const intScoreTxt   = document.getElementById('intScoreTxt');
    const driftScoreTxt = document.getElementById('driftScoreTxt');

    const visMin = document.getElementById('visMin'); const visOut = document.getElementById('visOut');
    const presMin = document.getElementById('presMin'); const presOut = document.getElementById('presOut');

    const ema   = document.getElementById('ema');   const emaOut = document.getElementById('emaOut');
    const onTh  = document.getElementById('onTh');  const onOut  = document.getElementById('onOut');
    const offTh = document.getElementById('offTh'); const offOut = document.getElementById('offOut');

    const tau       = document.getElementById('tau');     const tauOut     = document.getElementById('tauOut');
    const intOnEl   = document.getElementById('intOn');   const intOnOut   = document.getElementById('intOnOut');
    const intOff    = document.getElementById('intOff');  const intOffOut  = document.getElementById('intOffOut');

    const driftTau    = document.getElementById('driftTau');   const driftTauOut = document.getElementById('driftTauOut');
    const driftOnEl   = document.getElementById('driftOn');    const driftOnOut  = document.getElementById('driftOnOut');
    const driftOff    = document.getElementById('driftOff');   const driftOffOut = document.getElementById('driftOffOut');
    const driftTorsoRel = document.getElementById('driftTorsoRel');
    const driftReset  = document.getElementById('driftReset');

    const useEma   = document.getElementById('useEma');
    const useInt   = document.getElementById('useInt');
    const useDrift = document.getElementById('useDrift');

    const showBaseline = document.getElementById('showBaseline');

    const calSecs     = document.getElementById('calSecs');
    const calSecsOut  = document.getElementById('calSecsOut');
    const calLive     = document.getElementById('calLive');
    const calStartBtn = document.getElementById('calStart');
    const calStatus   = document.getElementById('calStatus');
    const calProgRow  = document.getElementById('calProgRow');
    const calProg     = document.getElementById('calProg');
    const calTime     = document.getElementById('calTime');
    const calStats    = document.getElementById('calStats');
    const calMedian   = document.getElementById('calMedian');
    const calP95      = document.getElementById('calP95');
    const calN        = document.getElementById('calN');

    /* ---------- State ---------- */
    let hideStatusTimer = null;

    let poseDC = null;
    let poseEnabled = false;
    let poseWhere = 'sender';
    let poseTask = null;
    let poseLoopRunning = false;

    let prevLm = null;
    let baseLm = null;
    let moveEma = 0;
    let intScore = 0;
    let driftScore = 0;
    let moving = false;
    let movingSince = 0;
    let lastAboveOnTs = 0;
    let lastIntHitTs = 0;
    let lastDriftHitTs = 0;
    let lastTs = 0;

    let calActive = false, calStartMs = 0, calEndMs = 0;
    let calSamples = [];
    let lastGoodLm = null;
    let lastCalUIRedraw = 0;
    const CAL_RECAL_MS = 250;

    let offLink = { ema: false, int: false, drift: false };
    // ===== Alerts episode state (Motion) =====
    let _motionAlertId = null;
    let _motionSum = 0, _motionCount = 0;
    const runAsync = (p) => Promise.resolve(p).catch(()=>{});

    /* ---------- Utils for live pose gating ---------- */
    const hasLivePose = () => (performance.now() - lastPoseTs) < LIVE_POSE_TIMEOUT_MS;

    function updateStateRowVisibility() {
      if (!stateRow) return;
      stateRow.style.display = hasLivePose() ? '' : 'none';
    }

    function updateCalibrationAvailability() {
      const live = hasLivePose();
      if (calQuickBtn) calQuickBtn.disabled = !live || !!calActive;
      if (calStartBtn) calStartBtn.disabled = !live || !!calActive;
      updateStateRowVisibility();
    }
    setInterval(updateCalibrationAvailability, 500);

    /* ---------- Status overlay ---------- */
    function showStatus(msg) {
      if (statusEl && overlay) {
        statusEl.textContent = msg;
        overlay.classList.remove('hidden');
      }
      if (msg === 'Connected') {
        if (hideStatusTimer) clearTimeout(hideStatusTimer);
        hideStatusTimer = setTimeout(() => overlay?.classList.add('hidden'), STATUS_HIDE_AFTER_CONNECTED_MS);
      } else {
        if (hideStatusTimer) { clearTimeout(hideStatusTimer); hideStatusTimer = null; }
      }
    }

    /* ---------- Audio UI ---------- */
    function updateAudioButtons() {
      if (!enableAudioBtn || !disableAudioBtn) return;
      if (remoteVideo?.muted) {
        enableAudioBtn.style.display = 'block';
        disableAudioBtn.style.display = 'none';
      } else {
        enableAudioBtn.style.display = 'none';
        disableAudioBtn.style.display = 'block';
      }
    }
    if (enableAudioBtn) enableAudioBtn.style.display = 'block';
    async function tryStartMuted() {
      try { if (remoteVideo) { remoteVideo.muted = true; remoteVideo.volume = 1.0; await remoteVideo.play(); } }
      catch (e) { console.warn('autoplay (muted) blocked:', e); }
      updateAudioButtons();
    }
    on(enableAudioBtn, 'click', async (e) => {
      e?.stopPropagation?.(); e?.preventDefault?.();
      try { if (remoteVideo) { remoteVideo.muted = false; remoteVideo.volume = 1.0; await remoteVideo.play(); } }
      catch (err) { console.warn('unmute play blocked:', err); }
      updateAudioButtons();
    });
    on(disableAudioBtn, 'click', (e) => {
      e?.stopPropagation?.(); e?.preventDefault?.();
      if (remoteVideo) remoteVideo.muted = true;
      updateAudioButtons();
    });

    /* ---------- Fullscreen ---------- */
    const beginViewportSettle = (durationMs = 1200) => {
      let settleRAF = 0, settleUntil = performance.now() + durationMs;
      const tick = () => {
        alignCanvasToVideo();
        if (performance.now() < settleUntil) {
          settleRAF = requestAnimationFrame(tick);
        } else {
          cancelAnimationFrame(settleRAF); settleRAF = 0;
          alignCanvasToVideo();
        }
      };
      tick();
    };
    on(fsBtn, 'click', async (e) => {
      e?.stopPropagation?.();
      try {
        if (!document.fullscreenElement) {
          await (stage?.requestFullscreen?.call(stage) || document.documentElement.requestFullscreen());
          if (fsBtn) fsBtn.textContent = 'Exit fullscreen';
        } else {
          await document.exitFullscreen();
          if (fsBtn) fsBtn.textContent = 'Fullscreen';
        }
      } catch (err) { console.warn('fullscreen error', err); }
      beginViewportSettle();
    });
    document.addEventListener('fullscreenchange', () => {
      if (fsBtn) fsBtn.textContent = document.fullscreenElement ? 'Exit fullscreen' : 'Fullscreen';
      beginViewportSettle();
    });

    on(remoteVideo, 'loadedmetadata', () => { beginViewportSettle(); });
    on(remoteVideo, 'playing', () => { updateAudioButtons(); beginViewportSettle(); });
    on(remoteVideo, 'resize', beginViewportSettle);

    /* ---------- Canvas alignment ---------- */
    function containRect(containerW, containerH, contentW, contentH) {
      const scale = Math.min(containerW / (contentW||1), containerH / (contentH||1));
      const w = Math.round(contentW * scale);
      const h = Math.round(contentH * scale);
      return { width:w, height:h, left: Math.floor((containerW - w) / 2), top: Math.floor((containerH - h) / 2) };
    }
    function alignCanvasToVideo() {
      if (!stage || !remoteVideo || !poseCanvas) return;
      const stageBox = stage.getBoundingClientRect();
      const videoBox = remoteVideo.getBoundingClientRect();
      const containerW = Math.round(videoBox.width);
      const containerH = Math.round(videoBox.height);
      const vidW = remoteVideo.videoWidth || 1;
      const vidH = remoteVideo.videoHeight || 1;
      const fit = containRect(containerW, containerH, vidW, vidH);
      const leftCSS = Math.round((videoBox.left - stageBox.left) + fit.left);
      const topCSS = Math.round((videoBox.top - stageBox.top) + fit.top);
      poseCanvas.style.left = leftCSS + 'px';
      poseCanvas.style.top = topCSS + 'px';
      poseCanvas.style.width = fit.width + 'px';
      poseCanvas.style.height = fit.height + 'px';
      const dpr = window.devicePixelRatio || 1;
      const needW = Math.max(1, Math.round(fit.width * dpr));
      const needH = Math.max(1, Math.round(fit.height * dpr));
      if (poseCanvas.width !== needW || poseCanvas.height !== needH) {
        poseCanvas.width = needW; poseCanvas.height = needH;
      }
      poseCtx.setTransform(1,0,0,1,0,0);
    }
    ['resize','orientationchange','scroll'].forEach(ev =>
      window.addEventListener(ev, () => beginViewportSettle(), { passive: true })
    );
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', () => beginViewportSettle(), { passive: true });
      window.visualViewport.addEventListener('scroll',  () => beginViewportSettle(), { passive: true });
    }
    document.addEventListener('visibilitychange', () => { if (!document.hidden) beginViewportSettle(); });

    function setOverlayVisible(v) {
      if (!poseCanvas) return;
      poseCanvas.style.display = v ? 'block' : 'none';
      if (v) beginViewportSettle();
      else poseCtx.clearRect(0,0, poseCanvas.width, poseCanvas.height);
    }

    /* ---------- Movement math helpers ---------- */
    const L = { L_SHOULDER: 11, R_SHOULDER: 12, L_HIP: 23, R_HIP: 24 };
    const lmOk = (p) =>
      p &&
      (p.visibility == null || p.visibility >= MOVE.VIS_MIN) &&
      (p.presence   == null || p.presence   >= MOVE.PRES_MIN);

    const dist2 = (a, b) => Math.hypot((a.x - b.x), (a.y - b.y));

    function torsoCenter(lm) {
      const ls = lm[L.L_SHOULDER], rs = lm[L.R_SHOULDER], lh = lm[L.L_HIP], rh = lm[L.R_HIP];
      const c = { x:0, y:0, n:0 };
      if (lmOk(ls) && lmOk(rs)) { c.x += (ls.x+rs.x)/2; c.y += (ls.y+rs.y)/2; c.n++; }
      if (lmOk(lh) && lmOk(rh)) { c.x += (lh.x+rh.x)/2; c.y += (lh.y+rh.y)/2; c.n++; }
      if (c.n) return { x: c.x/c.n, y: c.y/c.n };
      let n=0, sx=0, sy=0;
      for (const p of lm) if (lmOk(p)) { sx+=p.x; sy+=p.y; n++; }
      return n ? { x:sx/n, y:sy/n } : { x:0.5, y:0.5 };
    }

    function scaleFromTorso(lm) {
      const ls = lm[L.L_SHOULDER], rs = lm[L.R_SHOULDER];
      const lh = lm[L.L_HIP],      rh = lm[L.R_HIP];
      let s = 0;
      if (lmOk(ls) && lmOk(rs)) s = Math.max(s, dist2(ls, rs));
      if (lmOk(lh) && lmOk(rh)) s = Math.max(s, dist2(lh, rh));
      if (!s) {
        let minx=1, miny=1, maxx=0, maxy=0, any=false;
        for (const p of lm) if (lmOk(p)) { any=true; minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y); }
        if (any) s = Math.hypot(maxx-minx, maxy-miny);
      }
      return Math.max(s, MOVE.MIN_SCALE);
    }

    function rawMovementScore(lm, prev) {
      if (!lm || !prev || lm.length !== prev.length) return 0;
      const n = lm.length; const scale = scaleFromTorso(lm);
      let sum = 0, cnt = 0;
      for (let i=0; i<n; i++) { const a = lm[i], b = prev[i]; if (!lmOk(a) || !lmOk(b)) continue; sum += dist2(a, b); cnt++; }
      return cnt ? (sum / cnt) / scale : 0;
    }

    function computeDriftScore(lm, base, torsoRel=true) {
      if (!lm || !base || lm.length !== base.length) return 0;
      const n = lm.length; const scale = scaleFromTorso(lm);
      let sum = 0, cnt = 0;

      let cNow = {x:0,y:0}, cBase = {x:0,y:0};
      if (torsoRel) { cNow = torsoCenter(lm); cBase = torsoCenter(base); }

      for (let i=0; i<n; i++) {
        const a = lm[i], b = base[i];
        if (!lmOk(a) || !lmOk(b)) continue;
        const ax = a.x - (torsoRel ? cNow.x : 0), ay = a.y - (torsoRel ? cNow.y : 0);
        const bx = b.x - (torsoRel ? cBase.x : 0), by = b.y - (torsoRel ? cBase.y : 0);
        sum += Math.hypot(ax - bx, ay - by); cnt++;
      }
      return cnt ? (sum / cnt) / scale : 0;
    }

    function cloneLm(lm) {
      return lm?.map(p => p ? { x:p.x, y:p.y, z:p.z, visibility:p.visibility, presence:p.presence } : null) || null;
    }
    function blendLm(dst, src, a) {
      if (!src) return dst;
      if (!dst || dst.length !== src.length) dst = cloneLm(src);
      for (let i=0; i<src.length; i++) {
        const s = src[i]; if (!lmOk(s)) continue;
        if (!dst[i] || !lmOk(dst[i])) { dst[i] = { x:s.x, y:s.y, z:s.z, visibility:s.visibility, presence:s.presence }; continue; }
        const d = dst[i];
        d.x += a*(s.x - d.x); d.y += a*(s.y - d.y);
        if (s.z != null && d.z != null) d.z += a*(s.z - d.z);
        d.visibility = s.visibility ?? d.visibility;
        d.presence   = s.presence   ?? d.presence;
      }
      return dst;
    }

    /* ---------- Baseline overlay (ghost + vectors) ---------- */
    function lmToPx(p) {
      return { x: p.x * poseCanvas.width, y: p.y * poseCanvas.height };
    }
    function alignedBaseline(base, curr, torsoRel = true, scaleMatch = true) {
      if (!base || !curr || base.length !== curr.length) return null;
      if (!torsoRel) return base.map(p => p && ({ x:p.x, y:p.y, z:p.z, visibility:p.visibility, presence:p.presence })) || null;

      const cNow  = torsoCenter(curr);
      const cBase = torsoCenter(base);
      const sNow  = scaleFromTorso(curr);
      const sBase = Math.max(1e-6, scaleFromTorso(base));
      const r     = scaleMatch ? (sNow / sBase) : 1.0;

      return base.map((p) => {
        if (!p) return null;
        const x = cNow.x + r * (p.x - cBase.x);
        const y = cNow.y + r * (p.y - cBase.y);
        return { x, y, z: p.z, visibility: p.visibility, presence: p.presence };
      });
    }

    function drawBaselineGhostAndVectors(currLm) {
      if (!MOVE.SHOW_BASELINE || !baseLm || !currLm || currLm.length !== baseLm.length) return;

      const baseAligned = alignedBaseline(baseLm, currLm, MOVE.DRIFT_TORSO_REL, /*scaleMatch*/false);
      if (!baseAligned) return;

      const ctx = poseCtx;
      const dpr = window.devicePixelRatio || 1;

      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.strokeStyle = 'rgba(80,200,255,0.95)';
      ctx.fillStyle   = 'rgba(80,200,255,0.70)';
      ctx.lineWidth   = Math.max(1, 1.5 * dpr);
      ctx.setLineDash([6 * dpr, 4 * dpr]);

      const utilsGhost = new DrawingUtils(ctx);
      utilsGhost.drawConnectors(baseAligned, PoseLandmarker.POSE_CONNECTIONS);

      ctx.setLineDash([]);
      const JOINT_R = 2 * dpr;
      for (let i = 0; i < baseAligned.length; i++) {
        const p = baseAligned[i];
        if (!lmOk(p)) continue;
        const P = lmToPx(p);
        ctx.beginPath(); ctx.arc(P.x, P.y, JOINT_R, 0, Math.PI * 2); ctx.fill();
      }
      ctx.restore();

      const scaleNow = scaleFromTorso(currLm);
      const onThresh = Math.max(1e-6, MOVE.DRIFT_ON);
      const minAlpha = 0.18;
      const maxAlpha = 1.00;

      for (let i = 0; i < currLm.length; i++) {
        const c = currLm[i], b = baseAligned[i];
        if (!lmOk(c) || !lmOk(b)) continue;

        const dx = c.x - b.x, dy = c.y - b.y;
        const dNorm = Math.hypot(dx, dy) / scaleNow;
        const ratio = dNorm / onThresh;
        const alpha = Math.max(minAlpha, Math.min(maxAlpha, ratio));

        let stroke = 'rgba(180,180,180,1)';
        if (ratio >= 0.9 && ratio < 1.0) stroke = 'rgba(255,193,7,1)';
        if (ratio >= 1.0)                 stroke = 'rgba(203,36,49,1)';

        const B = lmToPx(b), C = lmToPx(c);

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = stroke;
        ctx.lineWidth   = Math.max(1, 1.5 * dpr);
        ctx.beginPath();
        ctx.moveTo(B.x, B.y);
        ctx.lineTo(C.x, C.y);
        ctx.stroke();
        ctx.restore();
      }
    }

    /* ---------- Badge drawing ---------- */
    function drawMovementBadge(movingState, emaVal, intVal, driftVal) {
      if (!poseCtx) return;
      const ctx = poseCtx;
      const dpr = window.devicePixelRatio || 1;

      const BG        = movingState ? '#4a2a00' : '#111111';
      const BORDER    = movingState ? '#ffa64d' : 'rgba(255,255,255,0.25)';
      const TXT_DIM   = movingState ? '#ffcc80' : '#dddddd';

      const metrics = [
        { label: 'Short-term motion (EMA)',        val: emaVal,   on: MOVE.ON,       enabled: !!MOVE.USE_EMA },
        { label: 'Sustained motion (Integrator)',  val: intVal,   on: MOVE.INT_ON,   enabled: !!MOVE.USE_INT },
        { label: 'Baseline drift vs pose (DRIFT)', val: driftVal, on: MOVE.DRIFT_ON, enabled: !!MOVE.USE_DRIFT },
      ];

      const pad = Math.round(8*dpr);
      const x = pad, y = pad;
      const INNER = Math.round(8*dpr);
      const ROW_H = Math.round(20*dpr);
      const BAR_W = Math.round(190*dpr);
      const BAR_H = Math.round(8*dpr);

      function roundRectPath(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y,     x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x,     y + h, rr);
        ctx.arcTo(x,     y + h, x,     y,     rr);
        ctx.arcTo(x,     y,     x + w, y,     rr);
        ctx.closePath();
      }

      ctx.save();

      ctx.font = `${Math.round(12*dpr)}px -apple-system,system-ui,Segoe UI,Roboto,sans-serif`;
      const stateTxt = movingState ? '• MOVING' : '• STILL';
      const pillPadX = Math.round(10*dpr);
      const pillW    = Math.round(ctx.measureText(stateTxt).width + pillPadX*2);
      const pillH    = Math.round(20*dpr);

      ctx.font = `${Math.round(11*dpr)}px -apple-system,system-ui,Segoe UI,Roboto,sans-serif`;
      const maxLabelW = Math.max(...metrics.map(m => ctx.measureText(m.label).width));
      const LABEL_W   = Math.round(maxLabelW + Math.round(6*dpr));
      const PCT_W     = Math.round(ctx.measureText('100%+').width + Math.round(12*dpr));

      const HEADER_H  = pillH + Math.round(10*dpr);
      const boxW = Math.max(LABEL_W + INNER + BAR_W + INNER + PCT_W, pillW + INNER*2);
      const boxH = HEADER_H + INNER + (ROW_H * metrics.length) + INNER;

      ctx.globalAlpha = 0.7; ctx.fillStyle = BG; ctx.fillRect(x, y, boxW, boxH);
      ctx.globalAlpha = 0.9; ctx.strokeStyle = BORDER; ctx.lineWidth = Math.max(1, Math.round(1*dpr));
      ctx.strokeRect(x+0.5, y+0.5, boxW-1, boxH-1);

      const pillX = x + boxW - pillW - INNER;
      const pillY = y + Math.round((HEADER_H - pillH)/2);
      const pillFill   = movingState ? '#801721' : '#1a1a1a';
      const pillBorder = movingState ? '#3f0b10' : 'rgba(255,255,255,0.25)';
      const pillText   = '#ffffff';

      roundRectPath(ctx, pillX, pillY, pillW, pillH, pillH/2);
      ctx.fillStyle = pillFill; ctx.fill();
      ctx.strokeStyle = pillBorder; ctx.stroke();
      ctx.fillStyle = pillText; ctx.textBaseline = 'alphabetic';
      ctx.fillText(stateTxt, pillX + pillPadX, pillY + pillH - Math.round(6*dpr));

      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.beginPath();
      ctx.moveTo(x + INNER, y + HEADER_H + 0.5);
      ctx.lineTo(x + boxW - INNER, y + HEADER_H + 0.5);
      ctx.stroke();

      const baseY = y + HEADER_H + INNER;

      for (let i = 0; i < metrics.length; i++) {
        const m = metrics[i];
        const rowY = baseY + i*ROW_H;

        ctx.globalAlpha = m.enabled ? 1.0 : 0.35;
        ctx.fillStyle = TXT_DIM; ctx.textBaseline = 'alphabetic';
        ctx.fillText(m.label, x + INNER, rowY + Math.round(9*dpr));

        const barX = x + INNER + LABEL_W;
        const barY = rowY - Math.round(BAR_H/2) + Math.round(9*dpr);
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        ctx.fillRect(barX, barY, BAR_W, BAR_H);

        const onThres = Math.max(1e-6, m.on);
        const ratio = m.val / onThres;
        const fillW = Math.round(BAR_W * Math.max(0, Math.min(ratio, 1)));

        let fillCol = '#4caf50';
        if (ratio >= 0.9 && ratio < 1.0) fillCol = '#ffc107';
        if (ratio >= 1.0)               fillCol = '#801721';

        ctx.globalAlpha = m.enabled ? 1.0 : 0.35;
        ctx.fillStyle = fillCol;
        ctx.fillRect(barX, barY, fillW, BAR_H);

        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.moveTo(barX + BAR_W + 0.5, barY - Math.round(2*dpr));
        ctx.lineTo(barX + BAR_W + 0.5, barY + BAR_H + Math.round(2*dpr));
        ctx.stroke();

        const pct = Math.round(Math.max(0, ratio) * 100);
        const pctText = ratio >= 1 ? '100%+' : `${pct}%`;
        ctx.fillStyle = TXT_DIM; ctx.textBaseline = 'middle';
        ctx.fillText(pctText, barX + BAR_W + Math.round(8*dpr), barY + Math.round(BAR_H/2));

        ctx.globalAlpha = 1.0;
      }

      ctx.restore();
    }

    /* ---------- Panel state reflect ---------- */
    function reflectPanel() {
      if (emaScoreTxt)   emaScoreTxt.textContent   = moveEma.toFixed(3);
      if (intScoreTxt)   intScoreTxt.textContent   = intScore.toFixed(3);
      if (driftScoreTxt) driftScoreTxt.textContent = driftScore.toFixed(3);
      if (moveStateTxt) {
        moveStateTxt.textContent  = moving ? 'MOVING' : 'STILL';
        moveStateTxt.classList.toggle('moving', moving);
        moveStateTxt.classList.toggle('still', !moving);
      }
    }

    // Make Reset buttons match Start button width
    function matchButtonSizes() {
      if (!movePanel || movePanel.classList.contains('hidden') || !calStartBtn) return;
      const rect = calStartBtn.getBoundingClientRect();
      const w = Math.ceil(rect.width);
      if (!w || w < 10) return;
      [driftReset, moveReset].forEach(btn => {
        if (!btn) return;
        btn.style.minWidth = w + 'px';
        btn.style.width = w + 'px';
      });
    }

    function updateCalQuickUI(active, secsLeft = null) {
      if (!calQuickBtn) return;
      if (!active) {
        calQuickBtn.disabled = !hasLivePose();
        calQuickBtn.innerHTML = 'Calibration';
        calQuickBtnActive = false;
        return;
      }
      calQuickBtn.disabled = true;
      const secsTxt = (secsLeft == null) ? '' : ` ${secsLeft}s`;
      calQuickBtn.innerHTML = `<span class="spinner" aria-hidden="true"></span>Calibrating…${secsTxt}`;
    }

    /* ---------- Main draw for live pose ---------- */
    function drawPoseLandmarks(landmarks) {
      if (!landmarks?.length || !poseCanvas.width || !poseCanvas.height) return;
      const utils = new DrawingUtils(poseCtx);

      for (const lm of landmarks) {
        try { drawBaselineGhostAndVectors(lm); } catch (e) { console.warn('[baseline overlay]', e); }
        utils.drawLandmarks(lm, {
          radius: (data) => DrawingUtils.lerp((data.from && data.from.z) ?? 0, -0.15, 0.1, 5, 1)
        });
        utils.drawConnectors(lm, PoseLandmarker.POSE_CONNECTIONS);
      }
    }

    /* ---------- Movement update ---------- */
    function updateMovementFromLandmarks(lm, canSend=true) {
      const now = performance.now();
      lastPoseTs = now;
      updateCalibrationAvailability();

      if (!lastTs) lastTs = now;
      const dt = Math.max(1/120, Math.min(0.2, (now - lastTs) / 1000));
      lastTs = now;

      const raw = rawMovementScore(lm, prevLm);
      prevLm = lm;
      moveEma = moveEma + MOVE.EMA_ALPHA * (raw - moveEma);
      if (raw >= MOVE.ON) lastAboveOnTs = now;
      const shortTrigger = (moveEma >= MOVE.ON);
      const shortHoldOk  = (moveEma > MOVE.OFF) || ((now - lastAboveOnTs) < MOVE.OFF_HOLD_MS);

      const decay = Math.exp(-dt / MOVE.INT_TAU);
      intScore = intScore * decay + raw * dt;
      const longTrigger = (intScore >= MOVE.INT_ON);
      if (longTrigger) lastIntHitTs = now;
      const longHoldOk  = (intScore > MOVE.INT_OFF) || ((now - lastIntHitTs) < MOVE.OFF_HOLD_MS);

      if (!baseLm) baseLm = cloneLm(lm);
      driftScore = computeDriftScore(lm, baseLm, MOVE.DRIFT_TORSO_REL);
      const driftTrigger = (driftScore >= MOVE.DRIFT_ON);
      if (driftTrigger) lastDriftHitTs = now;
      const driftHoldOk  = (driftScore > MOVE.DRIFT_OFF) || ((now - lastDriftHitTs) < MOVE.OFF_HOLD_MS);

      let wantMoving = false;
      if (MOVE.USE_EMA)   wantMoving ||= moving ? shortHoldOk  : shortTrigger;
      if (MOVE.USE_INT)   wantMoving ||= moving ? longHoldOk   : longTrigger;
      if (MOVE.USE_DRIFT) wantMoving ||= moving ? driftHoldOk  : driftTrigger;

      // ==== Alerts integration: begin/finish Motion episodes + accumulate avg ====
      if (wantMoving !== moving) {
        const prev = moving;
        moving = wantMoving;
      
        if (moving) {
          movingSince = now;
          _motionSum = 0; _motionCount = 0;
      
          // Start a Motion alert + show the red top banner (matches audio page)
          runAsync((async () => {
            _motionAlertId = await beginAlert({
              type: (AlertTypes?.Motion ?? 'motion'),
              message: 'Movement detected'
            });
            //showAlertBanner(Date.now());
            showAlertBanner(Date.now(), 'Motion detected');
          })());
        } else if (prev && _motionAlertId != null) {
          // Finish the Motion alert with an average score (use integrator as sustained proxy)
          const avg = _motionCount > 0 ? (_motionSum / _motionCount) : intScore;
          const id = _motionAlertId; _motionAlertId = null;
          runAsync(finishAlert(id, {
            avgScore: Number(avg.toFixed(4)),
            message: 'Movement ended'
          }));
        }
      }

// While moving, accumulate integrator score for an avg across the episode
if (moving) { _motionSum += intScore; _motionCount++; }
// ==== /Alerts integration ====


      if (!moving && baseLm) {
        const a = 1 - Math.exp(-dt / MOVE.DRIFT_TAU);
        baseLm = blendLm(baseLm, lm, a);
      }

      if (calActive) {
        calSamples.push(raw);
        lastGoodLm = cloneLm(lm);
        const durMs = Math.max(1000, Math.round((calEndMs - calStartMs)));
        const t = now - calStartMs;
        if (calProg) calProg.value = Math.min(1, t / durMs);
        const secsLeft = Math.max(0, Math.ceil((calEndMs - now)/1000));
        if (calTime) calTime.textContent = secsLeft + 's';
        if (calStatus) {
          calStatus.className = 'running';
          calStatus.textContent = `Calibrating… ${secsLeft}s`;
        }
        if (calQuickBtnActive) updateCalQuickUI(true, secsLeft);

        if ((now - lastCalUIRedraw) >= CAL_RECAL_MS) {
          lastCalUIRedraw = now;
          const m   = quantile(calSamples, 0.5);
          const p95 = quantile(calSamples, 0.95);
          const n   = calSamples.length;

          if (calStats) calStats.style.display = 'block';
          if (calMedian) calMedian.textContent = m.toFixed(4);
          if (calP95)    calP95.textContent    = p95.toFixed(4);
          if (calN)      calN.textContent      = String(n);

          if (MOVE.CAL_LIVE && n >= 20) {
            applyThresholdsFromStats(m, p95, /*isFinal=*/false);
          }
        }

        if (now >= calEndMs) finishCalibration();
      }

      poseCtx.save();
      try {
        drawMovementBadge(moving, moveEma, intScore, driftScore);
      } catch (e) {
        console.error('[drawMovementBadge]', e);
      } finally {
        try { poseCtx.restore(); } catch {}
      }
      reflectPanel();

      if (canSend && poseWhere === 'receiver' && poseDC?.readyState === 'open') {
        poseDC.send(JSON.stringify({ type: 'movement', where: 'receiver', moving, scoreEma: moveEma, scoreInt: intScore, scoreDrift: driftScore, ts: now }));
      }
    }

    /* ---------- Calibration helpers ---------- */
    function quantile(arr, q) {
      if (!arr.length) return 0;
      const a = arr.slice().sort((x,y)=>x-y);
      const pos = (a.length - 1) * q;
      const i = Math.floor(pos), j = Math.ceil(pos);
      if (i === j) return a[i];
      const w = pos - i;
      return a[i]*(1-w) + a[j]*w;
    }

    function applyThresholdsFromStats(m, p95, isFinal) {
      if (!onTh || !offTh || !intOnEl || !intOff || !driftOnEl || !driftOff) return;
      const emaOn   = Math.max(3.5*m, 1.2*p95, 0.01);
      const intOn   = MOVE.INT_TAU * m * 2.5;
      const driftOn = Math.max(5.0*m, 1.5*emaOn, 0.02);

      MOVE.ON        = Math.max(0.005, emaOn);
      MOVE.INT_ON    = Math.max(0.005, intOn);
      MOVE.DRIFT_ON  = Math.max(0.005, driftOn);

      if (isFinal || offLink.ema)   { MOVE.OFF       = MOVE.ON; }
      if (isFinal || offLink.int)   { MOVE.INT_OFF   = MOVE.INT_ON; }
      if (isFinal || offLink.drift) { MOVE.DRIFT_OFF = MOVE.DRIFT_ON; }

      onTh.value       = MOVE.ON;       if (onOut)      onOut.textContent      = MOVE.ON.toFixed(3);
      intOnEl.value    = MOVE.INT_ON;   if (intOnOut)   intOnOut.textContent   = MOVE.INT_ON.toFixed(3);
      driftOnEl.value  = MOVE.DRIFT_ON; if (driftOnOut) driftOnOut.textContent = MOVE.DRIFT_ON;

      offTh.value      = Math.min(MOVE.OFF, MOVE.ON);
      if (offOut) offOut.textContent = (MOVE.OFF = Math.min(MOVE.OFF, MOVE.ON)).toFixed(3);

      intOff.value     = Math.min(MOVE.INT_OFF, MOVE.INT_ON);
      if (intOffOut) intOffOut.textContent = (MOVE.INT_OFF = Math.min(MOVE.INT_OFF, MOVE.INT_ON)).toFixed(3);

      driftOff.value   = Math.min(MOVE.DRIFT_OFF, MOVE.DRIFT_ON);
      if (driftOffOut) driftOffOut.textContent = (MOVE.DRIFT_OFF = Math.min(MOVE.DRIFT_OFF, MOVE.DRIFT_ON)).toFixed(3);

      applyOnCaps();
    }

    function startCalibration() {
      if (calActive) return;
      calActive = true;
      updateCalibrationAvailability();

      calStartMs = performance.now();
      calEndMs   = calStartMs + (Math.max(5, Math.min(60, MOVE.CAL_SECS)) * 1000);
      calSamples = [];
      lastGoodLm = null;
      lastCalUIRedraw = 0;

      if (calStats)   calStats.style.display = 'none';
      if (calStatus) {
        calStatus.className = 'running';
        calStatus.textContent = `Calibrating… ${Math.round((calEndMs - calStartMs)/1000)}s`;
      }
      if (calProgRow) calProgRow.style.display = 'grid';
      if (calProg)    calProg.value = 0;
      if (calTime)    calTime.textContent = Math.round((calEndMs - calStartMs)/1000) + 's';

      offLink = { ema: true, int: true, drift: true };
    }

    function finishCalibration() {
      calActive = false;
      updateCalibrationAvailability();
      if (calProgRow) calProgRow.style.display = 'none';

      const m   = quantile(calSamples, 0.5);
      const p95 = quantile(calSamples, 0.95);
      const n   = calSamples.length;

      applyThresholdsFromStats(m, p95, /*isFinal=*/true);

      if (lastGoodLm) baseLm = cloneLm(lastGoodLm);
      moveEma = 0; intScore = 0; driftScore = 0; lastTs = 0;

      saveMoveConfig();
      initMovePanel();

      if (calMedian) calMedian.textContent = m.toFixed(4);
      if (calP95)    calP95.textContent    = p95.toFixed(4);
      if (calN)      calN.textContent      = String(n);
      if (calStats)  calStats.style.display = 'block';

      if (calStatus) { calStatus.className = 'ok'; calStatus.textContent = 'Calibrated'; }
      setTimeout(()=>{ if (!calActive && calStatus) calStatus.textContent = ''; }, 3000);

      if (calQuickBtnActive) {
        updateCalQuickUI(false);
        closeMovePanel();
      }
    }

    function clearOverlayDrawing() {
      try { poseCtx.setTransform(1,0,0,1,0,0); poseCtx.clearRect(0, 0, poseCanvas.width, poseCanvas.height); } catch {}
    }
    function attachStreamEndHandlers(stream) {
      if (!stream) return;
      stream.getVideoTracks().forEach((t) => {
        t.addEventListener('ended',  clearOverlayDrawing);
        t.addEventListener('mute',   clearOverlayDrawing);
      });
      stream.addEventListener('removetrack', (e) => { if (e.track?.kind === 'video') clearOverlayDrawing(); });
    }

    /* ---------- MediaPipe on RECEIVER ---------- */
    let useRVFC = false;
    async function ensurePoseTask() {
      if (poseTask) return poseTask;
      const vision = await FilesetResolver.forVisionTasks(WASM_DIR);
      poseTask = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: POSE_MODEL_URL, delegate: "GPU" },
        runningMode: "VIDEO",
        numPoses: 1
      });
      return poseTask;
    }
    const videoHasFrame = (v) => v && v.readyState >= HAVE_CURRENT_DATA && v.videoWidth > 0 && v.videoHeight > 0;
    function waitForVideoFrame(video) {
      if (videoHasFrame(video)) return Promise.resolve();
      return new Promise((resolve) => {
        const check = () => { if (videoHasFrame(video)) { cleanup(); resolve(); } };
        const cleanup = () => { video.removeEventListener('loadedmetadata', check); video.removeEventListener('playing', check); video.removeEventListener('resize', check); };
        video.addEventListener('loadedmetadata', check);
        video.addEventListener('playing', check);
        video.addEventListener('resize', check);
      });
    }
    async function startReceiverPoseLoop() {
      if (poseLoopRunning) return;
      await ensurePoseTask(); await waitForVideoFrame(remoteVideo);
      useRVFC = 'requestVideoFrameCallback' in (remoteVideo || {});
      poseLoopRunning = true;

      const onFrame = () => {
        if (!poseLoopRunning || !poseEnabled || poseWhere !== 'receiver') return;
        if (!videoHasFrame(remoteVideo)) { poseCtx.clearRect(0,0, poseCanvas.width, poseCanvas.height); updateCalibrationAvailability(); scheduleNext(); return; }
        try {
          const ts = performance.now();
          const result = poseTask.detectForVideo(remoteVideo, ts);
          if (result?.landmarks?.length) {
            const lm = result.landmarks[0];
            poseCtx.clearRect(0,0, poseCanvas.width, poseCanvas.height);
            drawPoseLandmarks([lm]);
            updateMovementFromLandmarks(lm, /*canSend=*/true);
            if (poseDC?.readyState === 'open') {
              poseDC.send(JSON.stringify({ type:'pose', landmarks:[lm], ts }));
            }
          } else {
            prevLm = null;
            poseCtx.clearRect(0,0, poseCanvas.width, poseCanvas.height);
            updateCalibrationAvailability();
          }
        } catch (err) {}
        finally { scheduleNext(); }
      };
      const scheduleNext = () => { if (useRVFC) remoteVideo.requestVideoFrameCallback(onFrame); else requestAnimationFrame(onFrame); };
      scheduleNext();
    }
    function stopReceiverPoseLoop() {
      poseLoopRunning = false;
      prevLm = null; moveEma = 0; intScore = 0; driftScore = 0; lastTs = 0;
      poseCtx.clearRect(0,0, poseCanvas.width, poseCanvas.height);
      reflectPanel();
      updateCalibrationAvailability();
    }
    function applyPoseMode() {
      setOverlayVisible(poseEnabled);
      if (!poseEnabled) { stopReceiverPoseLoop(); return; }
      if (poseWhere === 'receiver') startReceiverPoseLoop();
      else stopReceiverPoseLoop();
    }

    /* ---------- Shared WebRTC core ---------- */
    const core = new ReceiverCore({
      wsEndpoint: WS_ENDPOINT,
      room,
      onStatus: showStatus,
      onStream: (stream) => {
        if (remoteVideo && remoteVideo.srcObject !== stream) {
          remoteVideo.srcObject = stream;
          tryStartMuted();
          attachStreamEndHandlers(stream);
        }
      },
      onIceState: (state) => {
        if (state === 'failed' || state === 'disconnected' || state === 'closed') {
          clearOverlayDrawing();
          lastPoseTs = 0; updateCalibrationAvailability();
        }
      },
      onBye: () => {
        clearOverlayDrawing();
        lastPoseTs = 0; updateCalibrationAvailability();
      },
      onCreatePC: (pc) => {
        const ch = pc.createDataChannel('pose');
        ch.onopen = () => {};
        ch.onclose = () => {};
        ch.onerror = () => {};
        ch.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'pose-mode') {
              poseEnabled = !!msg.enabled;
              poseWhere   = msg.where || 'sender';
              applyPoseMode();
            } else if (msg.type === 'pose') {
              if (poseEnabled && poseWhere === 'sender' && msg.landmarks?.length) {
                const lm = msg.landmarks[0];
                poseCtx.clearRect(0,0, poseCanvas.width, poseCanvas.height);
                updateMovementFromLandmarks(lm, /*canSend=*/false);
                drawPoseLandmarks([lm]);
              } else {
                updateCalibrationAvailability();
              }
            }
          } catch {}
        };
        poseDC = ch;
      },
      onDataChannel: () => {}
    });

    core.start().catch(()=>{});
    // ===== Alerts pill + history (shared) =====
    // Will add an "Alerts" button with a red-count badge into #controls,
    // and render the sortable/filterable history drawer into #alertsModalHost.
    initAlertsUI({ drawerHostId: 'alertsModalHost' });

    /* ---------- Panel logic ---------- */
    function loadMoveConfig() {
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return {};
        const obj = JSON.parse(raw);
        const cfg = {};
        for (const k of Object.keys(MOVE_DEFAULTS)) {
          if (typeof obj[k] === typeof MOVE_DEFAULTS[k]) cfg[k] = obj[k];
        }
        return cfg;
      } catch { return {}; }
    }
    function saveMoveConfig() { try { localStorage.setItem(LS_KEY, JSON.stringify(MOVE)); } catch {} }
    const clampUi = (v,min,max)=>Math.max(min,Math.min(max,v));
    const fmt = (n,d=3)=>Number(n).toFixed(d);

    function applyOnCaps() {
      if (!onTh || !offTh || !driftOnEl || !driftOff || !intOnEl || !intOff) return;
      const HEADROOM = 1.2, MAX_SAFE = 10.0;

      const setMaxWithHeadroom = (inputEl, baseCap, calibratedVal) => {
        const need = Math.min(MAX_SAFE, Math.max(baseCap, calibratedVal * HEADROOM));
        inputEl.max = Number.isFinite(need) ? need.toFixed(3) : (baseCap.toFixed ? baseCap.toFixed(3) : String(baseCap));
      };

      setMaxWithHeadroom(onTh,      0.500, MOVE.ON);       offTh.max = onTh.max;
      setMaxWithHeadroom(driftOnEl, 1.000, MOVE.DRIFT_ON); driftOff.max = driftOnEl.max;
      setMaxWithHeadroom(intOnEl,   Math.min(2.0, MOVE.INT_TAU * 0.8), MOVE.INT_ON); intOff.max = intOnEl.max;

      if (parseFloat(onTh.value) > parseFloat(onTh.max)) onTh.value = onTh.max;
      MOVE.ON = parseFloat(onTh.value) || MOVE.ON; if (onOut) onOut.textContent = fmt(MOVE.ON);

      if (parseFloat(driftOnEl.value) > parseFloat(driftOnEl.max)) driftOnEl.value = driftOnEl.max;
      MOVE.DRIFT_ON = parseFloat(driftOnEl.value) || MOVE.DRIFT_ON; if (driftOnOut) driftOnOut.textContent = fmt(MOVE.DRIFT_ON);

      if (parseFloat(intOnEl.value) > parseFloat(intOnEl.max)) intOnEl.value = intOnEl.max;
      MOVE.INT_ON = parseFloat(intOnEl.value) || MOVE.INT_ON; if (intOnOut) intOnOut.textContent = fmt(MOVE.INT_ON);

      if (offLink.ema || MOVE.OFF > MOVE.ON)                 MOVE.OFF = Math.min(MOVE.OFF, MOVE.ON);
      if (offLink.int || MOVE.INT_OFF > MOVE.INT_ON)         MOVE.INT_OFF = Math.min(MOVE.INT_OFF, MOVE.INT_ON);
      if (offLink.drift || MOVE.DRIFT_OFF > MOVE.DRIFT_ON)   MOVE.DRIFT_OFF = Math.min(MOVE.DRIFT_OFF, MOVE.DRIFT_ON);

      offTh.value     = Math.min(parseFloat(offTh.max), MOVE.OFF);           if (offOut)     offOut.textContent     = fmt(MOVE.OFF);
      intOff.value    = Math.min(parseFloat(intOff.max), MOVE.INT_OFF);      if (intOffOut)  intOffOut.textContent  = fmt(MOVE.INT_OFF);
      driftOff.value  = Math.min(parseFloat(driftOff.max), MOVE.DRIFT_OFF);  if (driftOffOut)driftOffOut.textContent= fmt(MOVE.DRIFT_OFF);
    }

    function initMovePanel() {
      if (!movePanel) return;

      if (visMin && visOut) { visMin.value = MOVE.VIS_MIN; visOut.textContent = fmt(MOVE.VIS_MIN,2); }
      if (presMin && presOut) { presMin.value = MOVE.PRES_MIN; presOut.textContent = fmt(MOVE.PRES_MIN,2); }

      if (useEma) useEma.checked = !!MOVE.USE_EMA;
      if (ema && emaOut) { ema.value = MOVE.EMA_ALPHA; emaOut.textContent = fmt(MOVE.EMA_ALPHA,2); }
      if (onTh && onOut) { onTh.value = MOVE.ON; onOut.textContent = fmt(MOVE.ON); }
      if (offTh && offOut) { offTh.value = Math.min(MOVE.OFF, MOVE.ON); offOut.textContent = fmt(MOVE.OFF = Math.min(MOVE.OFF, MOVE.ON)); }

      if (useInt) useInt.checked = !!MOVE.USE_INT;
      if (tau && tauOut) { tau.value = MOVE.INT_TAU; tauOut.textContent = fmt(MOVE.INT_TAU,1)+' s'; }
      if (intOnEl && intOnOut) { intOnEl.value = MOVE.INT_ON; intOnOut.textContent = fmt(MOVE.INT_ON); }
      if (intOff && intOffOut) { intOff.value = Math.min(MOVE.INT_OFF, MOVE.INT_ON); intOffOut.textContent = fmt(MOVE.INT_OFF = Math.min(MOVE.INT_OFF, MOVE.INT_ON)); }

      if (useDrift) useDrift.checked = !!MOVE.USE_DRIFT;
      if (driftTau && driftTauOut) { driftTau.value = MOVE.DRIFT_TAU; driftTauOut.textContent = fmt(MOVE.DRIFT_TAU,1)+' s'; }
      if (driftOnEl && driftOnOut) { driftOnEl.value = MOVE.DRIFT_ON; driftOnOut.textContent = fmt(MOVE.DRIFT_ON); }
      if (driftOff && driftOffOut) { driftOff.value = Math.min(MOVE.DRIFT_OFF, MOVE.DRIFT_ON); driftOffOut.textContent = fmt(MOVE.DRIFT_OFF = Math.min(MOVE.DRIFT_OFF, MOVE.DRIFT_ON)); }
      if (driftTorsoRel) driftTorsoRel.checked = !!MOVE.DRIFT_TORSO_REL;

      if (showBaseline) showBaseline.checked = !!MOVE.SHOW_BASELINE;

      if (calSecs && calSecsOut) {
        calSecs.value = clampUi(MOVE.CAL_SECS, 5, 60);
        calSecsOut.textContent = `${calSecs.value} s`;
        MOVE.CAL_SECS = parseInt(calSecs.value,10);
      }
      if (calLive) calLive.checked = !!MOVE.CAL_LIVE;

      applyOnCaps();
      reflectPanel();
      updateStateRowVisibility();

      requestAnimationFrame(matchButtonSizes);
    }

    function openMovePanel(){
      if (!movePanel) return;
      movePanel.classList.remove('hidden');
      requestAnimationFrame(() => requestAnimationFrame(matchButtonSizes));
    }
    const closeMovePanel = ()=>{ if (movePanel) movePanel.classList.add('hidden'); };

    on(moveBtn, 'click', (e) => {
      e?.stopPropagation?.();
      if (!movePanel) return;
      movePanel.classList.toggle('hidden');
      if (!movePanel.classList.contains('hidden')) requestAnimationFrame(matchButtonSizes);
    });
    on(moveClose,'click', (e) => { e?.stopPropagation?.(); closeMovePanel(); });

    // Close panel when clicking anywhere outside (main page)
    document.addEventListener('click', (e) => {
      if (!movePanel || movePanel.classList.contains('hidden')) return;
      if (movePanel.contains(e.target)) return;
      closeMovePanel();
    });

    on(visMin, 'input', ()=>{ MOVE.VIS_MIN = clampUi(parseFloat(visMin.value),0,0.99); if (visOut) visOut.textContent = fmt(MOVE.VIS_MIN,2); saveMoveConfig(); });
    on(presMin,'input', ()=>{ MOVE.PRES_MIN = clampUi(parseFloat(presMin.value),0,0.99); if (presOut) presOut.textContent = fmt(MOVE.PRES_MIN,2); saveMoveConfig(); });

    on(useEma,   'change', ()=>{ MOVE.USE_EMA = !!useEma.checked; saveMoveConfig(); });
    on(useInt,   'change', ()=>{ MOVE.USE_INT = !!useInt.checked; saveMoveConfig(); });
    on(useDrift, 'change', ()=>{ MOVE.USE_DRIFT = !!useDrift.checked; saveMoveConfig(); });

    on(showBaseline, 'change', ()=>{ MOVE.SHOW_BASELINE = !!showBaseline.checked; saveMoveConfig(); });

    on(ema, 'input', ()=>{
      MOVE.EMA_ALPHA = clampUi(parseFloat(ema.value),0.01,0.90);
      if (emaOut) emaOut.textContent = fmt(MOVE.EMA_ALPHA,2);
      saveMoveConfig();
    });
    on(onTh, 'input', ()=>{
      MOVE.ON = Math.max(0.005, parseFloat(onTh.value) || 0);
      if (offLink.ema || MOVE.OFF > MOVE.ON) {
        MOVE.OFF = MOVE.ON;
        if (offTh && offOut) { offTh.value = MOVE.OFF; offOut.textContent = fmt(MOVE.OFF); }
      }
      if (onOut) onOut.textContent = fmt(MOVE.ON);
      applyOnCaps(); saveMoveConfig();
    });
    on(offTh, 'input', ()=>{
      offLink.ema = false;
      MOVE.OFF = Math.max(0.005, Math.min(parseFloat(offTh.value)||0, MOVE.ON, parseFloat(offTh.max)));
      offTh.value = MOVE.OFF; if (offOut) offOut.textContent = fmt(MOVE.OFF);
      saveMoveConfig();
    });

    on(tau, 'input', ()=>{
      MOVE.INT_TAU = clampUi(parseFloat(tau.value),0.5,8.0);
      if (tauOut) tauOut.textContent = fmt(MOVE.INT_TAU,1)+' s';
      applyOnCaps(); saveMoveConfig();
    });
    on(intOnEl, 'input', ()=>{
      MOVE.INT_ON = Math.max(0.005, parseFloat(intOnEl.value) || 0);
      if (offLink.int || MOVE.INT_OFF > MOVE.INT_ON) {
        MOVE.INT_OFF = MOVE.INT_ON;
        if (intOff && intOffOut) { intOff.value = MOVE.INT_OFF; intOffOut.textContent = fmt(MOVE.INT_OFF); }
      }
      if (intOnOut) intOnOut.textContent = fmt(MOVE.INT_ON);
      applyOnCaps(); saveMoveConfig();
    });
    on(intOff, 'input', ()=>{
      offLink.int = false;
      MOVE.INT_OFF = Math.max(0.005, Math.min(parseFloat(intOff.value)||0, MOVE.INT_ON, parseFloat(intOff.max)));
      intOff.value = MOVE.INT_OFF; if (intOffOut) intOffOut.textContent = fmt(MOVE.INT_OFF);
      saveMoveConfig();
    });

    on(driftTau, 'input', ()=>{
      MOVE.DRIFT_TAU = clampUi(parseFloat(driftTau.value),0.5,8.0);
      if (driftTauOut) driftTauOut.textContent = fmt(MOVE.DRIFT_TAU,1)+' s';
      saveMoveConfig();
    });
    on(driftOnEl, 'input', ()=>{
      MOVE.DRIFT_ON = Math.max(0.005, parseFloat(driftOnEl.value) || 0);
      if (offLink.drift || MOVE.DRIFT_OFF > MOVE.DRIFT_ON) {
        MOVE.DRIFT_OFF = MOVE.DRIFT_ON;
        if (driftOff && driftOffOut) { driftOff.value = MOVE.DRIFT_OFF; driftOffOut.textContent = fmt(MOVE.DRIFT_OFF); }
      }
      if (driftOnOut) driftOnOut.textContent = fmt(MOVE.DRIFT_ON);
      applyOnCaps(); saveMoveConfig();
    });
    on(driftOff, 'input', ()=>{
      offLink.drift = false;
      MOVE.DRIFT_OFF = Math.max(0.005, Math.min(parseFloat(driftOff.value)||0, MOVE.DRIFT_ON, parseFloat(driftOff.max)));
      driftOff.value = MOVE.DRIFT_OFF; if (driftOffOut) driftOffOut.textContent = fmt(MOVE.DRIFT_OFF);
      saveMoveConfig();
    });
    on(driftTorsoRel, 'change', ()=>{ MOVE.DRIFT_TORSO_REL = !!driftTorsoRel.checked; saveMoveConfig(); });

    on(driftReset, 'click', ()=>{ baseLm = null; if (calStatus) { calStatus.className='muted'; calStatus.textContent='Baseline reset'; } });

    on(calSecs, 'input', ()=>{
      MOVE.CAL_SECS = Math.max(5, Math.min(60, parseInt(calSecs.value,10) || 15));
      if (calSecsOut) calSecsOut.textContent = `${MOVE.CAL_SECS} s`;
      saveMoveConfig();
      if (calActive) calEndMs = calStartMs + MOVE.CAL_SECS * 1000;
      matchButtonSizes();
    });
    on(calLive, 'change', ()=>{ MOVE.CAL_LIVE = !!calLive.checked; saveMoveConfig(); });

    // Settings Start
    on(calStartBtn, 'click', (e) => {
      e?.stopPropagation?.();
      openMovePanel();
      if (!hasLivePose() || calActive) { updateCalibrationAvailability(); return; }
      startCalibration();
    });

    // Main-page Calibration button
    on(calQuickBtn, 'click', (e) => {
      e?.stopPropagation?.();
      if (calActive || !hasLivePose()) { updateCalibrationAvailability(); return; }
      calQuickBtnActive = true;
      updateCalQuickUI(true, MOVE.CAL_SECS);
      openMovePanel();
      startCalibration();
    });

    function resetToDefaults() {
      Object.keys(MOVE).forEach(k => delete MOVE[k]);
      Object.assign(MOVE, MOVE_DEFAULTS);
      MOVE.OFF       = Math.min(MOVE.OFF,       MOVE.ON);
      MOVE.INT_OFF   = Math.min(MOVE.INT_OFF,   MOVE.INT_ON);
      MOVE.DRIFT_OFF = Math.min(MOVE.DRIFT_OFF, MOVE.DRIFT_ON);
      try { localStorage.removeItem(LS_KEY); } catch {}
      baseLm = null; prevLm = null; moveEma = 0; intScore = 0; driftScore = 0; lastTs = 0;
      offLink = { ema: false, int: false, drift: false };
      if (calActive) { calActive = false; if (calProgRow) calProgRow.style.display = 'none'; }
      initMovePanel(); applyOnCaps(); reflectPanel(); saveMoveConfig(); matchButtonSizes();
      if (calStatus) { calStatus.className = 'muted'; calStatus.textContent = 'Defaults restored'; }
      if (calStats)  { calStats.style.display = 'none'; }
    }
    on(moveReset, 'click', (e)=>{ e?.stopPropagation?.(); resetToDefaults(); });

    initMovePanel();
    updateCalibrationAvailability();
    window.addEventListener('load', matchButtonSizes);

    // Re-run sizing on resize (only when the panel is visible)
    window.addEventListener('resize', () => {
      if (!movePanel?.classList.contains('hidden')) matchButtonSizes();
    });

    ['pause','ended','emptied','stalled','suspend','waiting'].forEach((ev) => {
      on(remoteVideo, ev, () => { clearOverlayDrawing(); lastPoseTs = 0; updateCalibrationAvailability(); });
    });

    window.addEventListener('beforeunload', () => {
      try { core.close(); } catch {}
      if (hideStatusTimer) clearTimeout(hideStatusTimer);
      stopReceiverPoseLoop();
    });

    function beginViewportSetle(){ beginViewportSettle(); }

    /* ---------- Help drawer wiring (runs after injection) ---------- */
    function wireHelpOnce() {
      const sheet = document.getElementById('helpSheet');
      const backdrop = document.getElementById('helpBackdrop');
      const closeBtn = document.getElementById('helpClose');
      const bodyEl   = document.getElementById('helpBody');
      const helpBtn  = document.getElementById('helpBtn');

      if (!sheet || sheet.dataset.wired === '1') return;
      sheet.dataset.wired = '1';

      const openHelp = () => {
        sheet.classList.add('show');
        backdrop?.classList.add('show');
        document.body.classList.add('help-open');
      };
      const closeHelp = () => {
        sheet.classList.remove('show');
        backdrop?.classList.remove('show');
        document.body.classList.remove('help-open');
      };

      helpBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); openHelp(); });
      closeBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); closeHelp(); });
      backdrop?.addEventListener('click', closeHelp);
      document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeHelp(); });

      // Robust close handler for the “×” even if re-rendered
      document.addEventListener('click', (e) => {
        const btn = e.target && e.target.closest('#helpClose');
        if (!btn) return;
        e.preventDefault();
        e.stopPropagation();
        closeHelp();
      }, true);

      // Keep settings panel open when interacting with the help drawer
      document.addEventListener('click', (e) => {
        if (document.body.classList.contains('help-open')) {
          const liveSheet = document.getElementById('helpSheet');
          if (liveSheet?.contains(e.target)) e.stopPropagation();
        }
      }, true);

      // Smooth scroll for TOC links
      bodyEl?.addEventListener('click', (e) => {
        const a = e.target.closest('a[href^="#"]');
        if (!a) return;
        const id = a.getAttribute('href');
        const el = bodyEl.querySelector(id);
        if (el) { e.preventDefault(); el.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
      });
    }

    // Run when the HTML is injected; also try immediately in case it’s already present
    document.addEventListener('help:ready', wireHelpOnce);
    if (document.getElementById('helpSheet')) wireHelpOnce();
  </script>

    <!-- analytics -->
  <script type="module">
    import { installAnalytics } from '/hungryface/shared/analytics.js';
    window.analytics = installAnalytics({ feature: 'receiver-motion' });
    // Later: window.analytics.event('motion_opened');
  </script>
  
    <!-- Alerts UI hosts -->
    <div id="alertBannerHost"></div>
    <div id="alertsModalHost"></div>
</body>
</html>
