<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Naptio ‚Äì Weighted Top-K Training</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <link rel="icon" href="data:," />
  <link rel="stylesheet" href="/hungryface/webrtc/receiver/shared/sidebar.css" />
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; background:#000; color:#fff; font-family:-apple-system,system-ui,Segoe UI,Roboto,sans-serif; }
    #stage { padding:16px; box-sizing:border-box; display:flex; justify-content:center; }
    .panel { width:min(100%,1100px); background:#0b0b0b; border:1px solid #141414; border-radius:14px; padding:16px; margin:0 auto 24px; }
    h1 { margin:.2rem 0 .1rem; font-size:22px; }
    .muted { color:#aaa; font-size:12px; }

    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .btn { padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.4); background:transparent; color:#fff; font-weight:600; cursor:pointer; }
    .btn:active { transform:scale(.98); }
    .btn[disabled] { opacity:.6; cursor:default; }
    .small { padding:8px 10px; font-size:13px; border-radius:10px; }

    /* üî¥ Active state frame */
    .btn.live {
      border-color: #ff5252;
      box-shadow: 0 0 0 2px rgba(255,82,82,0.2), 0 0 12px rgba(255,82,82,0.35);
    }

    /* Pair layout */
    .btn-pair { display:flex; gap:10px; min-width:240px; }
    .btn-pair .btn { flex:1 1 0; min-width:120px; }

    /* Meter & state pill */
    .status-row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .meter { height:10px; border-radius:8px; background:#0a0a0a; border:1px solid #222; overflow:hidden; }
    .fill { height:100%; width:0%; background:linear-gradient(to right, rgba(96,165,250,.9), rgba(239,68,68,.9)); transition:width 120ms linear; }
    .pill { display:none; align-items:center; gap:8px; padding:6px 12px; border-radius:999px; border:1px solid #333; font-size:13px; font-weight:700; }
    .pill.on { background:#310000; border-color:#a00; color:#ffb3b3; }
    .pill.busy { position:relative; }
    .pill.busy::after { content:''; width:8px; height:8px; border-radius:50%; background: currentColor; opacity:.7; margin-left:6px; animation: pillPulse .9s ease-in-out infinite alternate; }
    .status-row + .meter { margin-top: 6px; }
    @keyframes pillPulse { from { transform: translateX(0) scale(0.8); opacity:.45; } to { transform: translateX(4px) scale(1); opacity:1; } }

    /* Carded sections */
    .card { background:#0a0a0a; border:1px solid #171717; border-radius:12px; padding:12px; margin-top:12px; }
    .card h2 { margin:0 0 8px 0; font-size:16px; }
    .subgroup { display:flex; gap:14px; align-items:center; padding:10px; border:1px dashed #1b1b1b; border-radius:10px; background:#0b0b0b; }
    .subgroup strong { min-width:150px; }

    /* Inputs */
    input[type="number"], input[type="text"] { padding:10px 12px; border-radius:10px; border:1px solid #222; background:#0b0b0b; color:#ddd; }
    input[type="file"] { font-size:13px; }
    select { padding:10px 12px; border-radius:10px; border:1px solid #222; background:#0b0b0b; color:#ddd; }

    /* Sliders */
    .slider-wrap { display:flex; align-items:center; gap:10px; }
    input[type="range"] { width:220px; }

    /* Charts */
    .chart-wrap { position: relative; }
    .chart-wrap > canvas { position: absolute; inset: 0; width: 100% !important; height: 100% !important; display: block; background:#0a0a0a; border-radius:10px; }
    .h160{height:160px;} .h170{height:170px;} .h180{height:180px;} .h320{height:320px;}
    .legend { margin-top:6px; display:flex; gap:12px; font-size:12px; color:#ccc; flex-wrap:wrap; }
    .key { width:14px; height:3px; border-radius:2px; display:inline-block; margin-right:4px; vertical-align:middle; }
    .blue { background:#60a5fa; } .red { background:#ef4444; } .green{ background:#22c55e; } .darkred { background:#991b1b; }

    .weights-grid { display:grid; grid-template-columns:1fr 1fr; gap:12px; align-items:start; }
    @media (max-width: 820px) { .weights-grid { grid-template-columns: 1fr; } }
    .weights-card h3 { margin:0 0 6px 0; font-size:14px; color:#ddd; }

    /* Logs */
    .log-panel { margin-top:12px; background:#0a0a0a; border:1px solid #222; border-radius:12px; }
    .log-toolbar { display:flex; gap:10px; align-items:center; padding:8px 10px; border-bottom:1px solid #1a1a1a; font-size:12px; color:#ddd; flex-wrap:wrap; }
    .log-body { max-height:300px; overflow:auto; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; line-height:1.4; padding:10px; }
    .log-line { white-space:pre-wrap; margin:0; padding:2px 0; border-bottom:1px dotted #111; }
    .log-time { color:#9ca3af; }
    .log-kind-info { color:#e5e7eb; }
    .log-kind-ok   { color:#86efac; }
    .log-kind-warn { color:#fbbf24; }
    .log-kind-err  { color:#fca5a5; }
    .log-kind-inf  { color:#93c5fd; }
    .log-code { display:block; background:#0b0b0b; border:1px solid #1f2937; border-radius:8px; padding:6px; margin-top:4px; overflow:auto; }

    /* Top bar */
    .topbar { display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }

    /* Help + modal */
    .help-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:110;opacity:0;pointer-events:none;transition:opacity .2s ease;}
    .help-backdrop.show{opacity:1;pointer-events:auto;}
    .help-sheet{position:fixed;right:0;top:0;height:100svh;width:min(92vw,420px);background:#121212;color:#f3f3f3;border-left:1px solid rgba(255,255,255,0.12);box-shadow:-12px 0 32px rgba(0,0,0,0.6);z-index:120;transform:translateX(100%);transition:transform .24s cubic-bezier(.2,.8,.2,1);display:flex;flex-direction:column;}
    .help-sheet.show{transform:translateX(0);}
    .help-header{position:sticky;top:0;z-index:1;background:rgba(18,18,18,0.96);backdrop-filter:blur(6px);display:flex;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid rgba(255,255,255,0.08);}
    .help-header h3{margin:0;font-size:16px;font-weight:700;color:#fff;}
    .help-header .close{appearance:none;border:none;background:transparent;color:#aaa;font-size:22px;cursor:pointer;padding:2px 6px;}
    .help-body{padding:10px 12px 16px;overflow-y:auto;-webkit-overflow-scrolling:touch;}
    .help-body p,.help-body li,.help-body td,.help-body th{font-size:13px;color:#ddd;line-height:1.45;}
    .help-body code,.help-body pre{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;}
    .help-toc{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 12px;padding-bottom:8px;border-bottom:1px dashed rgba(255,255,255,0.15);}
    .help-toc a{font-size:12px;color:#ddd;text-decoration:none;border:1px solid rgba(255,255,255,0.18);padding:6px 8px;border-radius:999px;}
    .help-toc a:active{transform:scale(0.98);}
    .help-section{margin:14px 0;}
    .help-section h4{margin:0 0 6px;font-size:14px;color:#fff;}
    .help-kv{width:100%;border-collapse:collapse;margin-top:6px;}
    .help-kv th,.help-kv td{border:1px solid rgba(255,255,255,0.12);padding:8px;vertical-align:top;}
    .help-kv th{background:rgba(255,255,255,0.06);font-weight:700;color:#eee;white-space:nowrap;}
    .help-kv td{color:#ddd;}
    .help-callout{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);border-radius:10px;padding:10px;}
    details.learn-more{border:1px solid rgba(255,255,255,0.12);border-radius:10px;padding:10px;background:rgba(255,255,255,0.04);}
    details.learn-more>summary{cursor:pointer;list-style:none;font-weight:700;color:#fff;}
    details.learn-more>summary::-webkit-details-marker{display:none;}
    details.learn-more[open]{background:rgba(255,255,255,0.06);}
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:140;}
    .modal.show{display:flex;}
    .modal-card{width:min(96%,1000px);max-height:90vh;overflow-y:auto;background:#0b0b0b;border:1px solid #242424;border-radius:14px;}
    .modal-head{position:sticky;top:0;display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid #1a1a1a;background:#0d0d0d;border-top-left-radius:14px;border-top-right-radius:14px;}
    .modal-actions{display:flex;gap:8px;align-items:center;}
    .modal-body{padding:12px;}
    .modal-head .close{appearance:none;border:none;background:transparent;color:#aaa;font-size:22px;cursor:pointer;padding:2px 6px;}
    .modal-head .close:active{transform:scale(0.98);}
    .modal{z-index:140;} .help-backdrop{z-index:180;} .help-sheet{z-index:190;}

    /* Mobile tweaks */
    @media (max-width: 560px) {
      .btn-pair { min-width:auto; width:100%; }
      .btn-pair .btn { min-width:0; flex:1; }
      .subgroup { flex-direction:column; align-items:stretch; }
      .subgroup strong { min-width:unset; }
      .slider-wrap { width:100%; }
      input[type="range"] { width:100%; }
      .row { gap:8px; }
      select, input[type="number"], input[type="text"] { width:100%; box-sizing:border-box; }
    }

    /* Hidden remote video host (for audio track) */
    #remote { position:absolute; width:1px; height:1px; left:-99999px; top:-99999px; }
  </style>
</head>
<body>
  
  <!-- Inject the shared sidebar markup + behavior (same snippet as pose/cry pages) https://chatgpt.com/c/68c85105-d464-8331-be03-071c3da1f850-->
  <script type="module">
    (async () => {
      try {
        const res = await fetch('/hungryface/webrtc/receiver/shared/sidebar.html', { cache: 'no-cache' });
        const html = await res.text();
        const wrap = document.createElement('div');
        wrap.innerHTML = html.trim();
        document.body.prepend(...wrap.childNodes);
  
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = '/hungryface/webrtc/receiver/shared/sidebar.js';
          s.onload = resolve;
          s.onerror = reject;
          document.body.appendChild(s);
        });
        console.log('[TRAIN][sidebar] loaded');
      } catch (err) {
        console.error('[TRAIN][sidebar] failed to load shared assets:', err);
      }
    })();
  </script>
  
  <div id="stage">
    <div class="panel">
      <header class="topbar">
        <h1 style="padding-left:2ch">Weighted Top-K Audio Detector Training (Late-fusion)</h1>
        <div class="row">
          <button id="btnOpenSettings" class="btn">Settings</button>
        </div>
      </header>

      <div class="row status-row" style="margin-top:8px;">
        <div id="status" class="muted">Booting‚Ä¶</div>
        <div id="statePill" class="pill">idle</div>
      </div>
      <div class="meter" title="Input level (RMS)">
        <div id="rmsFill" class="fill"></div>
      </div>

      <!-- ===== Panels ===== -->

      <!-- Training panel (dropdown-based) -->
      <div class="card" id="cardTraining">
        <h2>Training</h2>

        <div class="subgroup">
          <strong>Source</strong>
          <select id="TRAIN_SRC" style="min-width:220px;">
            <option value="sender" selected>Sender (WebRTC)</option>
            <option value="mic">Microphone (Receiver)</option>
            <option value="file">File</option>
            <option value="folder">Folder</option>
          </select>

          <div id="trainChooseWrap" class="row" style="margin-left:auto; gap:10px;">
            <input id="fileInp" type="file" accept="audio/*" style="display:none" />
            <button id="btnChooseFile" class="btn" style="display:none;">Choose file‚Ä¶</button>

            <input id="folderInp" type="file" webkitdirectory directory multiple style="display:none" />
            <button id="btnChooseFolder" class="btn" style="display:none;">Choose folder‚Ä¶</button>
          </div>

          <div class="btn-pair" style="margin-left:auto;">
            <!-- Single toggle button -->
            <button id="btnTrain" class="btn" aria-pressed="false">Start</button>
          </div>
        </div>
        <span id="trainInfo" class="muted"></span>
      </div>

      <!-- Model panel -->
      <div class="card" id="cardModel">
        <h2>Model</h2>
        <div class="row" style="gap:8px 10px;">
          <label style="display:flex;align-items:center;gap:8px;">
            <span>Model</span>
            <select id="MODEL_SELECT" style="width:220px;"></select>
          </label>
          <button id="btnRecompute" class="btn">Recompute Weights</button>
          <button id="btnClear" class="btn">Clear Model</button>
          <button id="btnExport" class="btn">Export Model</button>
        </div>
        <div class="muted" style="margin-top:6px;">Pick an existing model or choose ‚ÄúNew‚Ä¶‚Äù to create one. Train (mic/file/folder/sender), then click ‚ÄúRecompute Weights‚Äù.</div>
      </div>

      <!-- Quiet calibration panel -->
      <div class="card" id="cardCal">
        <h2>Quiet calibration</h2>

        <!-- Calibrate controls -->
        <div class="subgroup">
          <strong>Calibrate thresholds</strong>
          <div class="btn-pair">
            <!-- Single toggle button -->
            <button id="btnCal" class="btn" aria-pressed="false">Start</button>
          </div>
        </div>

        <!-- Sliders STACKED: Duration first -->
        <div class="subgroup">
          <strong>Duration</strong>
          <div class="slider-wrap">
            <input id="CAL_DUR_SLIDER" type="range" min="5" max="120" step="1" value="20" />
            <span id="CAL_DUR_LABEL">20s</span>
          </div>
        </div>

        <!-- Then Thresholds OFF and ON -->
        <div class="subgroup">
          <strong>Thresholds</strong>
          <div class="slider-wrap">
            <span class="muted" style="min-width:28px;">OFF</span>
            <input id="THR_OFF_SLIDER" type="range" min="0" max="1" step="0.01" />
            <span id="THR_OFF_LABEL">0.25</span>
          </div>
          <div class="slider-wrap">
            <span class="muted" style="min-width:28px;">ON</span>
            <input id="THR_ON_SLIDER" type="range" min="0" max="1" step="0.01" />
            <span id="THR_ON_LABEL">0.35</span>
          </div>
        </div>

        <div class="muted" style="margin-top:6px;">Keep the room quiet. (Uses the selected source: Mic or Sender.)</div>
      </div>

      <!-- Live detection panel -->
      <div class="card" id="cardDetect">
        <h2>Live audio detection</h2>
        <div class="subgroup">
          <strong>Detection</strong>
          <div class="btn-pair">
            <!-- Single toggle button -->
            <button id="btnDetect" class="btn" aria-pressed="false">Start</button>
          </div>
          <span class="muted">Uses the active model & thresholds and the selected source (Mic or Sender).</span>
        </div>
      </div>

      <!-- Live bars (hidden until used) -->
      <div class="card" id="cardLiveBars" style="display:none">
        <h2>Live top classes</h2>
        <div class="chart-wrap h160">
          <canvas id="bars"></canvas>
        </div>
        <div class="muted" style="margin-top:6px;">Uses the <b>Top-K</b> setting. Excluded classes are grey; we extend to show Top-K non-excluded.</div>
      </div>

      <!-- Weights ‚Äì preview vs saved -->
      <div class="card">
        <h2>Weights</h2>
        <div class="weights-grid">
          <div class="weights-card">
            <h3>Live dynamic weights (unsaved preview)</h3>
            <div class="chart-wrap h170">
              <canvas id="barsDynW"></canvas>
            </div>
            <span class="muted">Top-K normalized weights recomputed on every training inference. Not stored.</span>
          </div>
          <div class="weights-card">
            <h3>Active model weights (Top-K, normalized)</h3>
            <div class="chart-wrap h170">
              <canvas id="barsSavedW"></canvas>
            </div>
            <span class="muted">What detection uses (until you click ‚ÄúRecompute Weights‚Äù).</span>
          </div>
        </div>
      </div>

      <!-- Fused score chart -->
      <div class="card">
        <h2>Fused score over time</h2>
        <div class="subgroup" style="justify-content:flex-end">
          <label style="display:flex;align-items:center;gap:8px;">
            <span class="muted">Window (s)</span>
            <input id="CHART_WINDOW_S" type="number" min="5" step="5" value="30" style="width:84px;">
          </label>
        </div>
        <div class="chart-wrap h320">
          <canvas id="chart"></canvas>
        </div>
        <div class="legend">
          <span class="key blue"></span> fused (raw)
          <span class="key red"></span> fused (EMA)
          <span class="key darkred"></span> thresh ON
          <span class="key green"></span> thresh OFF
        </div>
      </div>

      <!-- Logs -->
      <div class="card">
        <div class="row" style="justify-content:space-between; width:100%;">
          <h2 style="margin:0;">Logs</h2>
          <button id="btnToggleLogs" class="btn">Display logs</button>
        </div>
        <div id="logsContainer" class="log-panel" style="display:none">
          <div class="log-toolbar">
            <label><input type="checkbox" id="LOG_ENABLE" checked> Log inference</label>
            <label><input type="checkbox" id="LOG_ALL" > Log ALL classes</label>
            <label>Top-N <input id="LOG_TOPN" type="number" min="1" step="1" value="5" style="width:64px;margin-left:6px;"></label>
            <label><input type="checkbox" id="LOG_AUTOSCROLL" checked> Autoscroll</label>
            <button id="LOG_CLEAR" class="btn" style="padding:6px 10px;">Clear Logs</button>
            <button id="LOG_EXPORT" class="btn" style="padding:6px 10px;">Export JSON</button>
          </div>
          <div id="logBody" class="log-body"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden host for remote audio track -->
  <video id="remote" autoplay playsinline muted></video>

  <!-- Settings modal -->
  <div id="settingsModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <div class="modal-head">
        <strong>Settings</strong>
        <div class="modal-actions">
          <button id="btnHelp" class="btn small" type="button" title="Open Help">Help</button>
          <button id="btnSettingsClose" class="close" type="button" title="Close" aria-label="Close">√ó</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="row" style="gap:10px; flex-wrap:wrap;">
          <label style="display:grid; gap:6px; min-width:220px;"><span>Sample Rate (target Hz)</span><input id="SR_TARGET" type="number" min="8000" step="1000" value="16000" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>Frame length (s)</span><input id="FRAME_LEN_S" type="number" min="0.1" step="0.005" value="0.975" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>Hop (s)</span><input id="HOP_S" type="number" min="0.01" step="0.01" value="0.48" /></label>

          <label style="display:grid; gap:6px; min-width:220px;"><span>Per-class EMA œÑ (s)</span><input id="CLASS_EMA_TAU_S" type="number" min="0.1" step="0.1" value="0.8" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>Fused score EMA œÑ (s)</span><input id="FUSED_EMA_TAU_S" type="number" min="0.1" step="0.1" value="0.8" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>Min ON hold (ms)</span><input id="ALERT_HOLD_MS" type="number" min="0" step="100" value="3000" /></label>

          <label style="display:grid; gap:6px; min-width:220px;"><span>Quiet calibration (s)</span><input id="CAL_SEC_SETTINGS" type="number" min="5" step="1" value="20" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>OFF delta (below ON)</span><input id="ALERT_OFF_DELTA" type="number" min="0" step="0.01" value="0.10" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>Top-K classes</span><input id="TOP_K" type="number" min="1" step="1" value="6" /></label>

          <label style="display:grid; gap:6px; min-width:220px;"><span>Hybrid prior (kPrior)</span><input id="K_PRIOR" type="number" min="1" step="1" value="50" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>Hybrid half-life (s, training EMA)</span><input id="HALF_LIFE_S" type="number" min="30" step="10" value="3600" /></label>
          <label style="display:grid; gap:6px; min-width:220px;"><span>Max results from MP</span><input id="MAX_RESULTS" type="number" min="5" step="1" value="25" /></label>

          <label style="display:grid; gap:6px; min-width:320px;"><span>Ignore classes (training)</span>
            <input id="IGNORE_CLASSES" type="text" value="Silence, Inside, Outside, Vehicle, Noise" placeholder="Silence, Background noise, White noise">
          </label>
          <label style="display:grid; gap:6px; min-width:320px;"><span>Penalty map (inference)</span>
            <input id="PENALTY_MAP" type="text" value="Silence:-0.01, White noise:-0.01" placeholder="Silence:-0.4, White noise:-0.2">
          </label>
        </div>
        <div class="row" style="margin-top:12px; justify-content:flex-end;">
          <button id="btnResetDefaults" class="btn small">Reset all defaults</button>
        </div>
      </div>
    </div>
  </div>

  <audio id="trainAudio" crossorigin="anonymous" style="display:none"></audio>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <!-- Load the external Help HTML (injected at runtime) -->
  <script type="module" src="./help-sheet.js"></script>

  <!-- ‚¨áÔ∏è PSK bootstrap (viewer); resolves room from query/Settings and installs shim -->
  <script type="module">
    import { installPskShim } from '/hungryface/webrtc/shared/psk/psk-ws-shim.js';
    import { requirePskOrRedirect } from '/hungryface/webrtc/shared/psk/require-psk.js';

    const qs = new URLSearchParams(location.search);
    const qsRoom   = (qs.get('room') || '').trim();
    const stored   = (localStorage.getItem('bm_receiver_room') || '').trim();
    const lastRoom = (localStorage.getItem('naptio:lastRoom') || '').trim();

    const preferRoom = qsRoom || stored || lastRoom || '';

    const env = await requirePskOrRedirect({
      intent: 'viewer',
      pairRoute: '/hungryface/webrtc/pairpsk/',
      preferRoom,
      fallbackRoom: 'Baby',
    });

    // Expose env + safe re-install hook (same API shape as sender)
    window.__pskEnv = env;
    window.__installPskForRoom = (room) => {
      try { window.__pskUndo?.(); } catch {}
      window.__pskUndo = installPskShim({ room });
      console.log('[PSK][receiver-fence] shim installed for room:', room);
      try {
        localStorage.setItem('bm_receiver_room', room);
        localStorage.setItem('naptio:lastRoom', room);
      } catch {}
    };

    if (!env.redirected) {
      const resolvedRoom = qsRoom || stored || lastRoom || env.room || 'Baby';
      window.__installPskForRoom(resolvedRoom);
      window.__pskRoom = resolvedRoom;
    }
  </script>
  
  <script type="module">
    /* ========= NEW: WebRTC (ReceiverCore) ========= */
    import { ReceiverCore } from "/hungryface/webrtc/receiver/shared/receiver-core.js";

    const WS_ENDPOINT = "wss://signaling-server-f5gu.onrender.com/ws";
    const room = window.__pskRoom || "Baby";

    // WebRTC holder
    const wrtc = {
      core: null,
      dc: null,
      stream: null,
      // Remote audio tap graph
      ctx: null, src: null, sink: null, node: null,
      audioEnabled: true,
      where: 'sender', // 'sender' (scores via DC) | 'receiver' (audio streamed; classify here)
      visualMeterFromTap: false, // we reuse existing RMS from classifyChunk
      connected: false,
    };

    /* ========= Helpers & UI (existing) ========= */
    const EL = id => document.getElementById(id);
    const ASM_LOG_MS = 2000;
    const SCORE_LOG_MS = 800;

    /* Settings modal */
    const _modal = EL('settingsModal');
    EL('btnOpenSettings').onclick = () => { _modal.classList.add('show'); _modal.setAttribute('aria-hidden','false'); };
    EL('btnSettingsClose').onclick = () => { _modal.classList.remove('show'); _modal.setAttribute('aria-hidden','true'); };
    _modal.addEventListener('click', (e) => { if (e.target === _modal) { _modal.classList.remove('show'); _modal.setAttribute('aria-hidden','true'); }});

    /* Help side-sheet wiring (unchanged) */
    function wireHelpOnce() {
      const sheet = document.getElementById('helpSheet');
      const backdrop = document.getElementById('helpBackdrop');
      const closeBtn = document.getElementById('helpClose');
      const bodyEl   = document.getElementById('helpBody');
      const helpBtn  = document.getElementById('btnHelp');
      if (!sheet || sheet.dataset.wired === '1') return;
      sheet.dataset.wired = '1';
      const openHelp = () => { sheet.classList.add('show'); backdrop?.classList.add('show'); };
      const closeHelp = () => { sheet.classList.remove('show'); backdrop?.classList.remove('show'); };
      helpBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); openHelp(); });
      closeBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); closeHelp(); });
      backdrop?.addEventListener('click', closeHelp);
      document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeHelp(); });
      document.addEventListener('click', (e) => { if (!sheet.classList.contains('show')) return; if (sheet.contains(e.target)) return; closeHelp(); });
      bodyEl?.addEventListener('click', (e) => {
        const a = e.target.closest('a[href^="#"]'); if (!a) return;
        const id = a.getAttribute('href'); const el = bodyEl.querySelector(id);
        if (el) { e.preventDefault(); el.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
      });
    }
    document.addEventListener('help:ready', wireHelpOnce);
    if (document.getElementById('helpSheet')) wireHelpOnce();

    /* Logs toggle */
    const btnToggleLogs = EL('btnToggleLogs');
    const logsContainer = EL('logsContainer');
    btnToggleLogs.onclick = () => {
      const visible = logsContainer.style.display !== 'none';
      logsContainer.style.display = visible ? 'none' : '';
      btnToggleLogs.textContent = visible ? 'Display logs' : 'Hide logs';
    };

    const LOGS = {
      body: EL('logBody'),
      enable: EL('LOG_ENABLE'),
      all: EL('LOG_ALL'),
      topn: EL('LOG_TOPN'),
      autoscroll: EL('LOG_AUTOSCROLL'),
      clearBtn: EL('LOG_CLEAR'),
      exportBtn: EL('LOG_EXPORT'),
      maxLines: 1200,
      lines: 0,
      records: []
    };
    function ts(){ return new Date().toLocaleTimeString(undefined,{hour12:false}); }
    function log(kind, msg, extraHtml, data){
      const p = document.createElement('div');
      p.className = `log-line log-kind-${kind}`;
      p.innerHTML = `<span class="log-time">[${ts()}]</span> ${msg}${extraHtml ? extraHtml : ''}`;
      LOGS.body.appendChild(p);
      LOGS.lines++;
      LOGS.records.push({ t: Date.now(), ts: new Date().toISOString(), kind, msg, data: data ?? null });
      while (LOGS.lines > LOGS.maxLines) { LOGS.body.removeChild(LOGS.body.firstChild); LOGS.lines--; }
      if (LOGS.records.length > LOGS.maxLines) LOGS.records.shift();
      if (LOGS.autoscroll.checked) LOGS.body.scrollTop = LOGS.body.scrollHeight;
    }
    LOGS.clearBtn.onclick = () => { LOGS.body.innerHTML = ''; LOGS.lines = 0; LOGS.records = []; };
    LOGS.exportBtn.onclick = () => {
      const payload = { version: 1, exportedAt: new Date().toISOString(), params: getParams(), records: LOGS.records };
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `cry_logs_${getModelName()}_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      log('ok','Exported logs JSON');
    };

    const els = (id => Object.fromEntries([
      'status','statePill','rmsFill','SR_TARGET','FRAME_LEN_S','HOP_S',
      'CLASS_EMA_TAU_S','FUSED_EMA_TAU_S','ALERT_HOLD_MS',
      'CAL_SEC_SETTINGS','ALERT_OFF_DELTA','TOP_K','K_PRIOR','HALF_LIFE_S','MAX_RESULTS',
      'btnDetect','btnCal','CAL_DUR_SLIDER','CAL_DUR_LABEL',
      'fileInp','folderInp','btnChooseFolder','btnChooseFile',
      'btnRecompute','btnClear','btnExport',
      'trainAudio','chart','bars','barsDynW','barsSavedW',
      'IGNORE_CLASSES','PENALTY_MAP','btnResetDefaults',
      'THR_OFF_SLIDER','THR_OFF_LABEL','THR_ON_SLIDER','THR_ON_LABEL',
      'MODEL_SELECT','CHART_WINDOW_S','cardLiveBars',
      'TRAIN_SRC','btnTrain','trainInfo'
    ].map(x => [x, document.getElementById(x)])) )();

    // Persist/consult who is doing inference when using Sender (WebRTC). //https://chatgpt.com/c/68c0b810-7a90-8325-abde-e96235904c27
    // WebRTC glue code can call setInferWhere('sender'|'receiver') whenever the mode changes.
    function setInferWhere(where){
      localStorage.setItem('cryInferWhere', (where === 'receiver') ? 'receiver' : 'sender');
    }
    function getInferWhere(){
      return localStorage.getItem('cryInferWhere') || 'sender'; // default: sender-side scores
    }
    
    function setStatus(s){
      let msg = s;
    
      // Only annotate when training source is "Sender (WebRTC)"
      if (els.TRAIN_SRC?.value === 'sender') {
        const where = getInferWhere();
        const tag = (where === 'receiver')
          ? 'WebRTC: streamed audio ‚Üí inference @ receiver'
          : 'WebRTC: sender scores ‚Üí inference @ sender';
        msg = `${s}  ‚Ä¢  ${tag}`;
      }
    
      els.status.textContent = msg;
      log('info', msg);
    }

    // Pill: only show during training or calibration
    function setPill(s, on=false){
      const show = (s === 'training' || s === 'calibrating');
      els.statePill.style.display = show ? 'inline-flex' : 'none';
      els.statePill.textContent = s;
      els.statePill.classList.toggle('on',   show && !!on);
      els.statePill.classList.toggle('busy', show && !!on);
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function emaStep(prev, x, a){ return prev + a * (x - prev); }
    function rmsToMeter(rms){
      const db = 20 * Math.log10(Math.max(1e-8, rms));
      const FLOOR_DB = -85;
      const norm = (db - FLOOR_DB) / (0 - FLOOR_DB);
      return clamp01(norm);
    }
    function alphaForTau(dt, tau){ return 1 - Math.exp(-dt / Math.max(1e-3, tau)); }
    function setRMS(x){ els.rmsFill.style.width = Math.round(rmsToMeter(x)*100)+'%'; }
    function resampleLinear(x, fromSr, toSr){
      if (fromSr === toSr) return x;
      const ratio = toSr / fromSr, n = Math.max(1, Math.round(x.length * ratio)), out = new Float32Array(n);
      const dx = (x.length - 1) / (n - 1);
      for (let i=0;i<n;i++){ const pos=i*dx, i0=Math.floor(pos), i1=Math.min(i0+1,x.length-1), t=pos-i0; out[i]=x[i0]*(1-t)+x[i1]*t; }
      return out;
    }
    function quantile(arr, q){
      if (!arr?.length) return 0;
      const a = [...arr].sort((x,y)=>x-y);
      const idx = (a.length - 1) * q;
      const lo = Math.floor(idx), hi = Math.ceil(idx);
      if (lo === hi) return a[lo];
      const t = idx - lo;
      return a[lo] * (1 - t) + a[hi] * t;
    }

    /* ========= Chart labels plugin (percent) ========= */
    const pctLabelPlugin = { id:'pctLabel', afterDatasetsDraw(chart, args, options) {
      if (!options || options.enabled !== true) return;
      if (chart.config.type !== 'bar') return;
      const ds = chart.data.datasets?.[0]; if (!ds) return;
      const { ctx } = chart; const meta = chart.getDatasetMeta(0);
      ctx.save(); ctx.font = (options?.font) || '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillStyle = options?.color || '#ddd';
      const data = ds.data || [];
      meta.data.forEach((bar, i) => {
        const v = Number(data[i]) || 0;
        const txt = `${Math.round(v * 100)}%`;
        const x = bar.x + 6; const y = bar.y + 4;
        ctx.fillText(txt, x, y);
      });
      ctx.restore();
    }};
    Chart.register(pctLabelPlugin);

    /* ========= MediaPipe (Audio) ========= */
    const AUDIO_PKG_URL = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-audio@0.10.0";
    const MODEL_URL = "https://storage.googleapis.com/mediapipe-models/audio_classifier/yamnet/float32/1/yamnet.tflite";
    const WASM_DIR  = AUDIO_PKG_URL + "/wasm";
    let AudioClassifier, FilesetResolver, _yamTask = null, _yamTaskPromise = null;

    try {
      const AudioMod = await import(AUDIO_PKG_URL);
      AudioClassifier = AudioMod.AudioClassifier;
      FilesetResolver = AudioMod.FilesetResolver;
      log('ok', 'MediaPipe Tasks Audio module loaded.');
    } catch (e) {
      log('err', 'Failed to import MediaPipe Tasks Audio. See console.'); console.error(e);
    }

    async function ensureAudioTask(maxResults=25) {
      if (_yamTask) return _yamTask;
      if (_yamTaskPromise) return _yamTaskPromise;
      _yamTaskPromise = (async () => {
        if (!AudioClassifier || !FilesetResolver) throw new Error('MediaPipe not available');
        log('info','Loading YAMNet model‚Ä¶');
        const resolver = await FilesetResolver.forAudioTasks(WASM_DIR);
        try {
          _yamTask = await AudioClassifier.createFromOptions(resolver, {
            baseOptions: { modelAssetPath: MODEL_URL },
            runningMode: "AUDIO_CLIPS",
            classifierOptions: { scoreThreshold: 0.0, maxResults: Math.max(5, maxResults|0) }
          });
          log('ok', `YAMNet ready (maxResults=${maxResults}).`);
          return _yamTask;
        } catch (e1) {
          const resp = await fetch(MODEL_URL + "?cb=" + Date.now(), { cache: "no-store" });
          if (!resp.ok) throw new Error(`yamnet fetch ${resp.status}`);
          const buf = new Uint8Array(await resp.arrayBuffer());
          _yamTask = await AudioClassifier.createFromOptions(resolver, {
            baseOptions: { modelAssetBuffer: buf },
            runningMode: "AUDIO_CLIPS",
            classifierOptions: { scoreThreshold: 0.0, maxResults: Math.max(5, maxResults|0) }
          });
          log('ok', `YAMNet ready (buffer, maxResults=${maxResults}).`);
          return _yamTask;
        }
      })();
      try { return await _yamTaskPromise; } finally { _yamTaskPromise = null; }
    }

    async function classifyMP(task, w, sr) {
      try { return await task.classify(w, sr); }
      catch (e1) {
        try { return await task.classify({ audioClip: w, sampleRateHz: sr }); }
        catch (e2) { log('err', `MediaPipe classify failed: ${e1?.message || e1} / ${e2?.message || e2}`); return null; }
      }
    }
    function extractCategories(result) {
      if (!result) return [];
      const r = Array.isArray(result) ? result[0] : result;
      const cats = r?.classifications?.[0]?.categories ?? r?.classificationResult?.classifications?.[0]?.categories ?? [];
      return (cats||[]).map(c => ({ score: c.score ?? 0, categoryName: (c.displayName || c.categoryName || '').trim() }));
    }

    /* ========= Model persistence ========= */
    const ACTIVE_MODEL_NAME_KEY = 'cryActiveModelName';
    function getModelName(){ return els.MODEL_SELECT?.value || localStorage.getItem(ACTIVE_MODEL_NAME_KEY) || 'default'; }
    function setModelName(name){
      localStorage.setItem(ACTIVE_MODEL_NAME_KEY, name);
      if (els.MODEL_SELECT) els.MODEL_SELECT.value = name;
    }
    function MODEL_KEY(){ return `cryModelV1_${getModelName()}`; }
    function CALIB_KEY(){ return `cryCalibV1_${getModelName()}`; }
    function IGNORE_KEY(){ return `cryIgnore_${getModelName()}`; }
    function PENALTY_KEY(){ return `cryPenalty_${getModelName()}`; }

    function loadModel() {
      const name = getModelName();
      const raw = localStorage.getItem(MODEL_KEY());
      const STARTER = {"Crying, sobbing":0.493,"Baby cry, infant cry":0.421,"Whimper":0.086};
      if (raw) {
        try {
          const m = JSON.parse(raw);
          if (name === 'default' && (!m.weights || !Object.keys(m.weights).length)) {
            m.weights = STARTER; // seed starter if default was saved empty
          }
          return m;
        } catch {}
      }
      // no saved record ‚Üí bootstrap
      return {
        version: 1,
        name,
        halfLifeSec: Number(els.HALF_LIFE_S.value),
        K: Number(els.TOP_K.value),
        kPrior: Number(els.K_PRIOR.value),
        classes: {},
        weights: (name === 'default') ? STARTER : {},
        updatedAt: Date.now()
      };
    }
    function saveModel(m){ m.name = getModelName(); localStorage.setItem(MODEL_KEY(), JSON.stringify(m)); }
    function clearModel(){
      localStorage.removeItem(MODEL_KEY());
      localStorage.removeItem(CALIB_KEY());
      localStorage.removeItem(IGNORE_KEY());
      localStorage.removeItem(PENALTY_KEY());
      log('warn',`Cleared model ‚Äú${getModelName()}‚Äù + its calibration & ignore/penalty settings.`);
    }

    /* List & select models */
    const NEW_MODEL_VALUE = '__NEW__';
    function listModelNames(){
      const names = [];
      for (let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (k && k.startsWith('cryModelV1_')) names.push(k.replace('cryModelV1_',''));
      }
      if (!names.includes('default')) names.push('default');
      names.sort((a,b)=>a.localeCompare(b));
      return names;
    }
    function refreshModelSelect(activeName){
      const sel = els.MODEL_SELECT;
      if (!sel) return;
      const names = listModelNames();
      sel.innerHTML = '';
      for (const n of names){
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n;
        sel.appendChild(opt);
      }
      const optNew = document.createElement('option');
      optNew.value = NEW_MODEL_VALUE; optNew.textContent = 'New‚Ä¶';
      sel.appendChild(optNew);
      sel.value = names.includes(activeName) ? activeName : (localStorage.getItem(ACTIVE_MODEL_NAME_KEY) || 'default');
    }

    /* ========= Ignore / Penalty ========= */
    function getIgnoreTokens(){
      const s = (els.IGNORE_CLASSES?.value ?? localStorage.getItem(IGNORE_KEY()) ?? '').trim();
      return s ? s.split(',').map(t=>t.trim().toLowerCase()).filter(Boolean) : [];
    }
    function shouldIgnore(name){
      if (!name) return false;
      const n = name.toLowerCase();
      return getIgnoreTokens().some(tok => n.includes(tok));
    }
    function getPenaltyMap(){
      const s = (els.PENALTY_MAP?.value ?? localStorage.getItem(PENALTY_KEY()) ?? '').trim();
      const map = {};
      if (!s) return map;
      s.split(',').forEach(pair=>{
        const [k,v] = pair.split(':');
        if (!k) return;
        const w = Math.max(-1, Math.min(0, parseFloat(v)));
        map[k.trim().toLowerCase()] = Number.isFinite(w) ? w : -0.3;
      });
      return map;
    }

    function resetDefaults(){
      els.SR_TARGET.value        = 16000;
      els.FRAME_LEN_S.value      = 0.975;
      els.HOP_S.value            = 0.48;
      els.CLASS_EMA_TAU_S.value  = 0.8;
      els.FUSED_EMA_TAU_S.value  = 0.8;
      els.ALERT_HOLD_MS.value    = 3000;
      els.CAL_SEC_SETTINGS.value = 20;
      els.CAL_DUR_SLIDER.value   = 20; updateCalDurLabel();
      els.ALERT_OFF_DELTA.value  = 0.10;
      els.TOP_K.value            = 6;
      els.K_PRIOR.value          = 50;
      els.HALF_LIFE_S.value      = 3600;
      els.MAX_RESULTS.value      = 25;
      els.IGNORE_CLASSES.value   = 'Silence, Inside, Outside, Vehicle, Noise';
      els.PENALTY_MAP.value      = 'Silence:-0.01, White noise:-0.01';
      localStorage.setItem(IGNORE_KEY(), els.IGNORE_CLASSES.value);
      localStorage.setItem(PENALTY_KEY(), els.PENALTY_MAP.value);

      ['TOP_K','K_PRIOR','HALF_LIFE_S'].forEach(id => {
        const el = document.getElementById(id);
        el && el.dispatchEvent(new Event('change'));
      });

      const m = loadModel();
      const preview = computeWeightsPreview(m);
      setWeightsChart(state.barDynW, preview);
      setWeightsChart(state.barSavedW, m.weights || {});
      if (state.mode === 'idle') clearTopBars();

      log('ok', 'Settings reset to defaults.');
    }
    els.btnResetDefaults && (els.btnResetDefaults.onclick = resetDefaults);

    /* ========= Stats ‚Üí weights ========= */
    function updateStats(model, categories, dtSec) {
      const a = alphaForTau(dtSec, model.halfLifeSec || 3600);
      for (const { categoryName: name, score=0 } of categories) {
        if (!name || shouldIgnore(name)) continue;
        const s = model.classes[name] || (model.classes[name] = { n:0, sum:0, ema:0, emaPres:0 });
        s.n   += 1; s.sum += score; s.ema  = emaStep(s.ema, score, a); s.emaPres = emaStep(s.emaPres, score>0 ? 1 : 0, a);
      }
      model.updatedAt = Date.now();
    }
    function computeWeightsPreview(model){
      const K = model.K || 6, kPrior = model.kPrior || 50;
      const raw = [];
      for (const [name, s] of Object.entries(model.classes || {})) {
        if (shouldIgnore(name)) continue;
        const mean = s.sum / Math.max(1, s.n);
        const lambda = kPrior / (kPrior + (s.n || 0));
        const hybrid = (1 - lambda) * mean + lambda * (s.ema ?? 0);
        const prevalence = clamp01(s.emaPres ?? 0);
        const score = Math.max(0, hybrid * (0.5 + 0.5 * prevalence));
        raw.push([name, score]);
      }
      if (!raw.length) return {};
      raw.sort((a,b)=>b[1]-a[1]);
      const top = raw.slice(0, K);
      const Z = top.reduce((acc,[,v])=>acc+v,0) || 1;
      return Object.fromEntries(top.map(([n,v])=>[n, v/Z]));
    }
    function recomputeWeights(model) {
      const preview = computeWeightsPreview(model);
      model.weights = preview;
      model.updatedAt = Date.now();
      saveModel(model);
      const lines = Object.entries(preview)
        .sort((a,b)=>b[1]-a[1])
        .map(([n,v]) => `${n.padEnd(24,' ')}  w=${(v).toFixed(3)}  n=${model.classes?.[n]?.n ?? 0}`);
      log('ok', `Recomputed weights for ‚Äú${getModelName()}‚Äù (Top-K normalized):`, `<div class="log-code">${lines.join('\n')}</div>`);
      return model.weights;
    }

    /* ========= Detection state & charts ========= */
    const state = {
      running: false,
      mode: 'idle',
      micCtx: null, srcNode: null, procNode: null, sinkNode: null,
      ring: new Float32Array(0), lastPos: 0,
      perClassEma: new Map(), fusedEma: 0,
      alertOn: false, alertUntil: 0,
      chart: null, barChart: null, barDynW: null, barSavedW: null,
      labels: [], fusedRaw: [], fusedSm: [],
      thrOn: 0.35, thrOff: 0.25,
      frameCount: 0, asmLastLogTs: 0,
      calActive: false, calVals: [], calTimerId: null, scoreLastLogTs: 0,
      calCountdownId: null,
      hopSec: 0.48,
      chartWindowSec: 30,
      chartCap: 0
    };

    /* ====== Toggle button helpers ====== */
    function setLiveBtn(btn, on){
      if (!btn) return;
      btn.classList.toggle('live', !!on);
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      btn.textContent = on ? 'Stop' : 'Start';
    }
	function updateToggleButtonsUI(){
	  const trainingOn = (state.mode === 'train' || state.mode === 'train_file' || state.mode === 'train_folder');
	  // Don't show Detect as "on" while calibrating, even though the graph runs in 'detect' mode
	  const detectOn = (state.mode === 'detect' && !state.calActive);
	  const calOn = !!state.calActive;
	
	  setLiveBtn(els.btnTrain, trainingOn);
	  setLiveBtn(els.btnDetect, detectOn);
	  setLiveBtn(els.btnCal, calOn);
	
	  // While calibrating, disable the Detect button so it can‚Äôt be toggled
	  els.btnDetect.disabled = state.calActive;
	}

    /* ====== Time-windowed chart helpers ====== */
    function hhmmss(tMs){
      const d = new Date(tMs);
      return d.toLocaleTimeString([], { hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' });
    }
    function computeChartCap(){
      const cap = Math.max(10, Math.round(state.chartWindowSec / Math.max(0.01, state.hopSec)));
      return cap;
    }
    function initChartBuffers(){
      state.chartCap = computeChartCap();
      state.labels   = new Array(state.chartCap).fill('');
      state.fusedRaw = new Array(state.chartCap).fill(null);
      state.fusedSm  = new Array(state.chartCap).fill(null);
    }

    function setupChart(){
      state.chart?.destroy?.();
      const ctx = els.chart.getContext('2d');
      initChartBuffers();
      state.chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: state.labels,
          datasets: [
            { label:'fused(raw)', data: state.fusedRaw, type:'bar', borderWidth:0, pointRadius:0, barPercentage:1.0, categoryPercentage:1.0, backgroundColor:'rgba(96,165,250,0.55)' },
            { label:'fused(EMA)', data: state.fusedSm, type:'line', borderWidth:2, pointRadius:0, tension:0.15, borderColor:'rgba(239,68,68,0.95)', spanGaps:true },
            { label:'thr ON',  data:new Array(state.chartCap).fill(state.thrOn), type:'line', borderWidth:1, pointRadius:0, borderDash:[6,4],  borderColor:'rgba(153,27,27,1)', spanGaps:true },
            { label:'thr OFF', data:new Array(state.chartCap).fill(state.thrOff), type:'line', borderWidth:1, pointRadius:0, borderDash:[2,2],  borderColor:'rgba(34,197,94,1)', spanGaps:true }
          ]
        },
        options: {
          responsive: true, maintainAspectRatio: false, animation:false, plugins:{ legend:{ display:false } },
          scales:{ x:{ title:{display:true, text:'time (local)'}, ticks:{ maxRotation:0, autoSkip:true } },
                  y:{ title:{display:true, text:'score'}, min:0, max:1.2, grid:{ color:'rgba(255,255,255,0.08)' } } }
        }
      });
    }

    function pushChart(nowMs, raw, sm){
      const capNow = computeChartCap();
      if (capNow !== state.chartCap) { setupChart(); }
      state.fusedRaw.shift(); state.fusedRaw.push(raw);
      state.fusedSm.shift();  state.fusedSm.push(sm);
      const dt = state.hopSec * 1000;
      for (let i=0;i<state.chartCap;i++){
        const t = nowMs - (state.chartCap - 1 - i) * dt;
        state.labels[i] = hhmmss(t);
      }
      state.chart.data.datasets[2].data = new Array(state.chartCap).fill(state.thrOn);
      state.chart.data.datasets[3].data = new Array(state.chartCap).fill(state.thrOff);
      state.chart.data.labels = state.labels.slice();
      state.chart.data.datasets[0].data = state.fusedRaw.slice();
      state.chart.data.datasets[1].data = state.fusedSm.slice();
      const nums = [...state.fusedRaw, ...state.fusedSm].filter(v => typeof v === 'number' && isFinite(v));
      const ymax = nums.length ? Math.max(...nums, state.thrOn, state.thrOff) + 0.05 : 1.0;
      state.chart.options.scales.y.max = Math.max(0.6, Math.min(1.5, ymax));
      state.chart.update();
    }

    /* ========= Live bars show/hide ========= */
    function showLiveBars(){
      if (els.cardLiveBars && els.cardLiveBars.style.display === 'none') {
        els.cardLiveBars.style.display = '';
        setTimeout(()=>{ state.barChart?.resize?.(); }, 0);
      }
    }
    function hideLiveBars(){ if (els.cardLiveBars) els.cardLiveBars.style.display = 'none'; }

    function setupBars(){
      if (!state.barChart && els.bars) {
        state.barChart = new Chart(els.bars.getContext('2d'), {
          type: 'bar',
          data: { labels: [], datasets: [{ label: 'score', data: [], borderWidth: 1, backgroundColor: [], borderColor: [], barThickness: 12, maxBarThickness: 14, categoryPercentage: 0.55, barPercentage: 0.9 }]},
          options: {
            indexAxis: 'y', responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display:false } },
            scales: { x: { min: 0, max: 1, title: { display:true, text:'score' }, ticks: { font: { size: 11 } } },
                      y: { ticks: { autoSkip: false, font: { size: 11 } } } }
          }
        });
      }
      if (!state.barDynW && els.barsDynW) {
        state.barDynW = new Chart(els.barsDynW.getContext('2d'), {
          type: 'bar',
          data: { labels: [], datasets: [{ label:'weight', data: [], borderWidth:1, barThickness:10, maxBarThickness:12, categoryPercentage:0.5, barPercentage:0.9 }]},
          options: {
            indexAxis:'y', responsive:true, maintainAspectRatio:false, animation:false,
            plugins:{ legend:{display:false}, pctLabel:{enabled: true, font:'11px system-ui', color:'#bbb'} },
            scales:{ x:{ min:0, max:1, title:{display:true, text:'weight'}, ticks:{ font:{ size:11 } } }, y:{ ticks:{ autoSkip:false, font:{ size:11 } } } }
          }
        });
      }
      if (!state.barSavedW && els.barsSavedW) {
        state.barSavedW = new Chart(els.barsSavedW.getContext('2d'), {
          type: 'bar',
          data: { labels: [], datasets: [{ label:'weight', data: [], borderWidth:1, barThickness:10, maxBarThickness:12, categoryPercentage:0.5, barPercentage:0.9 }]},
          options: {
            indexAxis:'y', responsive:true, maintainAspectRatio:false, animation:false,
            plugins:{ legend:{display:false}, pctLabel:{enabled: true, font:'11px system-ui', color:'#bbb'} },
            scales:{ x:{ min:0, max:1, title:{display:true, text:'weight'}, ticks:{ font:{ size:11 } } }, y:{ ticks:{ autoSkip:false, font:{ size:11 } } } }
          }
        });
      }
    }
    function clearTopBars(){
      if (!state.barChart) { hideLiveBars(); return; }
      state.barChart.data.labels = [];
      state.barChart.data.datasets[0].data = [];
      state.barChart.data.datasets[0].backgroundColor = [];
      state.barChart.data.datasets[0].borderColor = [];
      state.barChart.update();
      hideLiveBars();
    }
    function updateTopBars(cats){
      if (!els.bars) return;
      setupBars();
      const K = Math.max(1, Number(els.TOP_K.value) || 6);
      const sorted = [...cats].sort((a,b)=> (b.score||0)-(a.score||0));
      const display = [];
      let kept = 0, i = 0;
      while (i < sorted.length && kept < K) {
        const c = sorted[i++]; const excluded = shouldIgnore(c.categoryName);
        display.push({ name: c.categoryName || '(unnamed)', v: c.score || 0, excluded });
        if (!excluded) kept++;
      }
      const labels = display.map(d => d.name);
      const values = display.map(d => d.v);
      const bg = display.map(d => d.excluded ? 'rgba(107,114,128,0.85)' : 'rgba(96,165,250,0.85)');
      const bd = display.map(d => d.excluded ? 'rgba(75,85,99,1)' : 'rgba(59,130,246,1)');
      state.barChart.data.labels = labels;
      state.barChart.data.datasets[0].data = values;
      state.barChart.data.datasets[0].backgroundColor = bg;
      state.barChart.data.datasets[0].borderColor = bd;
      state.barChart.update();
      if (labels.length > 0) showLiveBars();
    }
    function setWeightsChart(chart, weightsDict){
      if (!chart) return;
      const entries = Object.entries(weightsDict || {}).sort((a,b)=>b[1]-a[1]);
      chart.data.labels = entries.map(([n]) => n);
      chart.data.datasets[0].data = entries.map(([,v]) => v);
      chart.update();
    }

    /* ========= Fusion scoring ========= */
    function ensurePerClassEma(weights) {
      for (const n of Object.keys(weights || {})) {
        if (!state.perClassEma.has(n)) state.perClassEma.set(n, 0);
      }
    }
    function fusedScoreFromCategories(categories, weights, dt) {
      const a = alphaForTau(dt, Number(els.CLASS_EMA_TAU_S.value) || 0.8);
      for (const c of categories) {
        const name = c.categoryName; if (!name) continue;
        const prev = state.perClassEma.get(name) || 0;
        state.perClassEma.set(name, emaStep(prev, c.score || 0, a));
      }
      ensurePerClassEma(weights);
      let fused = 0;
      for (const [name, w] of Object.entries(weights || {})) {
        fused += (w || 0) * (state.perClassEma.get(name) || 0);
      }
      const pmap = getPenaltyMap();
      if (Object.keys(pmap).length) {
        for (const [tok, pen] of Object.entries(pmap)) {
          const token = String(tok || '').toLowerCase(); if (!token) continue;
          for (const [nm, ema] of state.perClassEma.entries()) {
            if (nm.toLowerCase().includes(token)) fused += (pen || 0) * (ema || 0);
          }
        }
      }
      fused = clamp01(fused);
      state.fusedEma = emaStep(state.fusedEma, fused, alphaForTau(dt, Number(els.FUSED_EMA_TAU_S.value) || 0.8));
      return { raw: fused, sm: state.fusedEma };
    }
    function applyHysteresis(sm, nowMs){
      const hold = Number(els.ALERT_HOLD_MS.value) || 0;
      if (state.alertOn) { if (nowMs < state.alertUntil) return true; return sm >= state.thrOff; }
      else { if (sm >= state.thrOn) { state.alertUntil = nowMs + hold; return true; } return false; }
    }

    /* ========= Threshold slider helpers ========= */
    function setThrUI() {
      els.THR_OFF_SLIDER.value = String(state.thrOff.toFixed(2));
      els.THR_ON_SLIDER.value  = String(state.thrOn.toFixed(2));
      els.THR_OFF_LABEL.textContent = state.thrOff.toFixed(2);
      els.THR_ON_LABEL.textContent  = state.thrOn.toFixed(2);
    }
    function enableThrSliders(on) { els.THR_OFF_SLIDER.disabled = !on; els.THR_ON_SLIDER.disabled  = !on; }
    function persistThresholds(extra={}) {
      const prev = JSON.parse(localStorage.getItem(CALIB_KEY()) || 'null') || {};
      const payload = { ...prev, version: 1, thr_on: state.thrOn, thr_off: state.thrOff, at: new Date().toISOString(), ...extra };
      localStorage.setItem(CALIB_KEY(), JSON.stringify(payload));
      log('ok','Saved thresholds.', `<div class="log-code">${JSON.stringify(payload, null, 2)}</div>`);
    }

    els.THR_OFF_SLIDER.addEventListener('input', () => {
      state.thrOff = clamp01(parseFloat(els.THR_OFF_SLIDER.value) || 0);
      if (state.thrOn < state.thrOff) state.thrOn = state.thrOff;
      setThrUI();
    });
    els.THR_ON_SLIDER.addEventListener('input', () => {
      state.thrOn = clamp01(parseFloat(els.THR_ON_SLIDER.value) || 0);
      if (state.thrOn < state.thrOff) state.thrOff = state.thrOn;
      setThrUI();
    });
    ['change','blur'].forEach(evt => {
      els.THR_OFF_SLIDER.addEventListener(evt, () => { if (!state.calActive) persistThresholds(); });
      els.THR_ON_SLIDER.addEventListener(evt,  () => { if (!state.calActive) persistThresholds(); });
    });

    function updateCalLiveThresholds() {
      if (!state.calActive || state.calVals.length < 2) return;
      const offDelta = Number(els.ALERT_OFF_DELTA.value) || 0.10;
      const p99 = quantile(state.calVals, 0.995);
      const thr_off = Math.min(0.95, p99 + 0.02);
      const thr_on  = Math.min(0.99, thr_off + offDelta);
      state.thrOff = thr_off; state.thrOn = Math.max(thr_on, state.thrOff);
      setThrUI();
    }

    /* ========= Quiet calibration ========= */
    function updateCalDurLabel(){ els.CAL_DUR_SLIDER.textContent = els.CAL_DUR_SLIDER.value; els.CAL_DUR_LABEL.textContent = `${els.CAL_DUR_SLIDER.value}s`; }
    els.CAL_DUR_SLIDER.addEventListener('input', updateCalDurLabel);
    updateCalDurLabel();

    // NEW: common categories handler (used by both local classify and DC stream)
    function onCategories(cats, mode) {
      const HOP_S = Number(els.HOP_S.value)||0.48;
      if (state.calActive) { updateTopBars(cats); }

      if (LOGS.enable.checked) {
        const topN = Math.max(1, parseInt(LOGS.topn.value,10) || 5);
        const items = [...cats].sort((a,b)=>(b.score||0)-(a.score||0)).slice(0, LOGS.all.checked ? cats.length : topN)
                          .map(c => `${c.categoryName || '(unnamed)'}:${(c.score||0).toFixed(3)}`);
        const msg  = `Inf#${++state.frameCount} [${mode}] cats=${cats.length}`;
        log('inf', msg, `<div class="log-code"><strong>Top ${LOGS.all.checked ? cats.length : topN}</strong>:\n${items.join('\n')}</div>`, { mode, frame: state.frameCount, cats });
      }

      const trainingActive = (mode === 'train' || mode === 'train_file' || mode === 'train_folder') && (state.mode === mode);

      if (trainingActive) {
        updateTopBars(cats);
        const model = loadModel();
        model.halfLifeSec = Number(els.HALF_LIFE_S.value) || 3600;
        model.kPrior = Number(els.K_PRIOR.value) || 50;
        model.K = Number(els.TOP_K.value) || 6;
        updateStats(model, cats, HOP_S);
        saveModel(model);
        setWeightsChart(state.barDynW, computeWeightsPreview(model));
      } else if (mode === 'detect' && state.mode === 'detect') {
        updateTopBars(cats);
        const model = loadModel();
        model.K = Number(els.TOP_K.value) || model.K || 6;
        const weights = model.weights || {"Baby cry, infant cry":1};
        const { raw, sm } = fusedScoreFromCategories(cats, weights, HOP_S);

        const calib = JSON.parse(localStorage.getItem(CALIB_KEY()) || 'null');
        if (calib) { state.thrOn = calib.thr_on; state.thrOff = calib.thr_off; }
        else { state.thrOn = 0.35; state.thrOff = state.thrOn - (Number(els.ALERT_OFF_DELTA.value)||0.1); }

        pushChart(Date.now(), raw, sm);

        if (state.calActive) {
          state.calVals.push(sm);
          updateCalLiveThresholds();
        }

        if (LOGS.enable.checked) {
          const nowTs = performance.now();
          if (nowTs - state.scoreLastLogTs >= SCORE_LOG_MS) {
            const nextOn = (() => {
              const hold = Number(els.ALERT_HOLD_MS.value) || 0;
              if (state.alertOn) return (nowTs < state.alertUntil) ? true : (sm >= state.thrOff);
              return sm >= state.thrOn;
            })();
            const tag = state.calActive ? 'cal' : 'run';
            log('inf', `[${tag}] score raw=${raw.toFixed(3)} sm=${sm.toFixed(3)} | thrOn=${state.thrOn.toFixed(3)} thrOff=${state.thrOff.toFixed(3)} | alert=${nextOn ? 'ON' : 'off'}`);
            state.scoreLastLogTs = nowTs;
          }
        }

        const on = applyHysteresis(sm, performance.now());
        if (on && !state.alertOn) { log('ok','ALERT ON (cry detected).'); }
        if (!on && state.alertOn) { log('warn','ALERT OFF.'); }
        state.alertOn = on;
      }
    }

    async function quietCalibrate(){
      if (state.calActive) return;
      const uiDur = Number(els.CAL_DUR_SLIDER.value) || Number(els.CAL_SEC_SETTINGS.value) || 20;
      const durSec  = Math.max(5, uiDur);
      const offDelta = Number(els.ALERT_OFF_DELTA.value) || 0.10;

      state.calActive = true;
      state.calVals = [];
      setStatus(`Quiet calibration for ${durSec}s‚Ä¶ Please keep things quiet.`);
      enableThrSliders(false);
      updateToggleButtonsUI();

      await startInputForMode('detect'); // Mic or Sender
      setStatus(`Quiet calibration for ${durSec}s‚Ä¶ Please keep things quiet.`);
      setPill('calibrating', true);

      const startedAt = performance.now();
      const updateBtn = () => {
        if (!state.calActive) return;
        const left = Math.max(0, durSec - Math.floor((performance.now() - startedAt)/1000));
        // Keep button label as "Stop" per single-toggle UX
        // els.btnCal.textContent = `Stop (${left}s)`; // (optional if you want a countdown)
								   
      };
      updateBtn();
      state.calCountdownId = setInterval(updateBtn, 250);

      state.calTimerId = setTimeout(async () => {
        const vals = state.calVals.slice();
        state.calActive = false;
        clearInterval(state.calCountdownId); state.calCountdownId = null;
        // Keep button enabled for single-toggle UX
        state.calTimerId = null;

        if (!vals.length) {
          const thr_on = 0.35;
          const thr_off = Math.max(0, thr_on - offDelta);
          localStorage.setItem(CALIB_KEY(), JSON.stringify({ version: 1, thr_on, thr_off, n: 0, at: new Date().toISOString() }));
          state.thrOn = thr_on; state.thrOff = thr_off;
          setThrUI();
          enableThrSliders(true);
          await stopAll();
          setPill('idle', false);
          log('warn', 'Calibration captured 0 frames; using defaults.');
          updateToggleButtonsUI();
          return;
        }

        const p99 = quantile(vals, 0.995);
        const thr_off = Math.min(0.95, p99 + 0.02);
        const thr_on  = Math.min(0.99, thr_off + offDelta);
        state.thrOff = thr_off; state.thrOn = thr_on;

        const payload = { version: 1, thr_on, thr_off, n: vals.length, p99, off_delta: offDelta, dur_s: durSec, at: new Date().toISOString() };
        localStorage.setItem(CALIB_KEY(), JSON.stringify(payload));
        log('ok', 'Quiet calibration complete.', `<div class="log-code">${JSON.stringify(payload, null, 2)}</div>`);

        setThrUI();
        enableThrSliders(true);

        await stopAll();
        setPill('idle', false);
        setStatus('Calibration done. Adjust thresholds if needed, then start detection.');
        updateToggleButtonsUI();
      }, durSec * 1000);
    }
    function stopCalibrationEarly(){
      if (!state.calActive) return;
      state.calActive = false;
      if (state.calTimerId) { clearTimeout(state.calTimerId); state.calTimerId = null; }
      if (state.calCountdownId) { clearInterval(state.calCountdownId); state.calCountdownId = null; }
																	
      enableThrSliders(true);
      setPill('idle', false);
      stopAll();
      updateToggleButtonsUI();
    }

    /* ========= Classify loop & modes ========= */
    function concatFloat32(a,b){ const out=new Float32Array(a.length+b.length); out.set(a,0); out.set(b,a.length); return out; }

    async function classifyChunk(chunk, deviceSr, params, mode){
      if (state.mode !== mode) return;

      const SR_TARGET = Number(els.SR_TARGET.value)||16000;
      const HOP_S = Number(els.HOP_S.value)||0.48;
      state.hopSec = HOP_S;
      const MAX_RESULTS = Number(els.MAX_RESULTS.value)||25;
      const task = await ensureAudioTask(MAX_RESULTS);

      let s=0; for(let i=0;i<chunk.length;i++){ const v=chunk[i]; s+=v*v; }
      setRMS(Math.sqrt(s/Math.max(1,chunk.length)));

      const x16 = resampleLinear(chunk, deviceSr, SR_TARGET);
      state.ring = concatFloat32(state.ring, x16);
      const fram = Math.round(0.975 * SR_TARGET);
      const hop  = Math.round(HOP_S * SR_TARGET);

      const now = performance.now();
      if (now - state.asmLastLogTs >= ASM_LOG_MS) {
        log('info', `Audio buf len=${state.ring.length}, need‚â•${state.lastPos + hop} (hop=${hop}, frame=${fram})`);
        state.asmLastLogTs = now;
      }

      while (state.ring.length - state.lastPos >= hop) {
        const end = state.lastPos + hop, start = Math.max(0, end - fram);
        let w = state.ring.slice(start, end); if (w.length !== fram) { const pad = new Float32Array(fram); pad.set(w, 0); w = pad; }

        const res = await classifyMP(task, w, SR_TARGET);
        const cats = extractCategories(res);

        onCategories(cats, mode);
        state.lastPos += hop;
        if (state.lastPos > fram * 4) {
          const cut = state.lastPos - fram;
          state.ring = state.ring.slice(cut);
          state.lastPos -= cut;
        }
      }
    }

    /* ========= Mic control ========= */
    async function startMic(mode) {
      await stopFolderTraining();
      await stopFilePlayback();
      await stopRemoteAudioTap(); // ensure remote tap is off
      await stopMicOnly();
      setStatus(mode==='detect' ? 'Starting microphone (detect)‚Ä¶' : 'Starting microphone (train)‚Ä¶');
      const ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive' });
      state.micCtx = ctx;
      await ctx.resume();
      log('info', `Mic AudioContext sampleRate=${ctx.sampleRate} Hz`);

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { channelCount:1, echoCancellation:false, noiseSuppression:false, autoGainControl:false },
        video: false
      });
      const src = ctx.createMediaStreamSource(stream);
      const sink = ctx.createGain(); sink.gain.value = 0; sink.connect(ctx.destination);
      state.srcNode = src; state.sinkNode = sink;

      try {
        const Code =
          'class Tap extends AudioWorkletProcessor {' +
          '  process(inputs){ const i=inputs[0]; if(i&&i[0]) this.port.postMessage(i[0].slice(0)); return true; }' +
          '}' +
          'registerProcessor("tap", Tap);';
        const url = URL.createObjectURL(new Blob([Code], { type: 'application/javascript; charset=utf-8' }));
        await ctx.audioWorklet.addModule(url); URL.revokeObjectURL(url);
        const node = new AudioWorkletNode(ctx, 'tap', { numberOfInputs:1, numberOfOutputs:1, channelCount:1 });
        node.port.onmessage = (ev)=> classifyChunk(ev.data, ctx.sampleRate, getParams(), mode);
        src.connect(node).connect(sink);
        state.procNode = node;
        log('info', 'AudioWorklet active @ '+ctx.sampleRate+' Hz');
      } catch (e) {
        const node = ctx.createScriptProcessor(4096,1,1);
        node.onaudioprocess = (ev)=> classifyChunk(new Float32Array(ev.inputBuffer.getChannelData(0)), ctx.sampleRate, getParams(), mode);
        src.connect(node).connect(sink);
        state.procNode = node;
        setStatus('ScriptProcessor active @ '+ctx.sampleRate+' Hz');
        log('warn', 'AudioWorklet fell back: ' + (e?.message || e));
        log('info', 'ScriptProcessor active @ '+ctx.sampleRate+' Hz');
      }
      state.running = true;
      state.mode = mode;
      setPill(mode==='detect' ? 'idle' : 'training', mode!=='detect');
      setupChart();
      log('ok', `Mic started in ${mode.toUpperCase()} mode.`);
      if (mode === 'train') setStatus('Training started (mic).');
      else if (mode === 'detect' && !state.calActive) setStatus('Detection started (mic).');
      updateToggleButtonsUI();
    }

    async function stopMicOnly(){
      try { state.procNode?.disconnect(); } catch {}
      try { state.srcNode?.disconnect(); } catch {}
      try { state.sinkNode?.disconnect(); } catch {}
      try { state.micCtx && state.micCtx.state!=='closed' && state.micCtx.close(); } catch {}
      state.procNode=null; state.srcNode=null; state.sinkNode=null; state.micCtx=null;
    }

    async function stopAll(){
      const wasRunning = state.running || state.mode!=='idle';
      state.running=false; state.mode='idle';
      await stopMicOnly();
      await stopRemoteAudioTap();
      state.ring=new Float32Array(0); state.lastPos=0; state.perClassEma.clear(); state.fusedEma=0; state.frameCount=0;
      state.asmLastLogTs = 0; state.scoreLastLogTs = 0;
      setPill('idle', false); setRMS(0);
      clearTopBars(); setupChart();
      if (wasRunning) log('warn','Stopped audio graph.');
      updateToggleButtonsUI();
    }

    /* ========= Training on FILE/FOLDER ========= */
    let trainCtx=null, trainSrc=null, trainNode=null, trainSink=null, trainBlobUrl=null;
    let trainUsingWorklet = false;

    async function ensureTrainGraph(modeLabel){
      if (!trainCtx) { trainCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'}); }
      if (trainCtx.state === 'suspended') await trainCtx.resume();

      if (!trainSink) { trainSink = trainCtx.createGain(); trainSink.gain.value = 0; trainSink.connect(trainCtx.destination); }
      if (!trainNode) {
        try {
          const workletCode =
            'class Tap extends AudioWorkletProcessor {' +
            '  process(inputs){ const i=inputs[0]; if(i&&i[0]) this.port.postMessage(i[0].slice(0)); return true; }' +
            '}' +
            'registerProcessor("tap", Tap);';
          const mod = URL.createObjectURL(new Blob([workletCode], { type: 'application/javascript; charset=utf-8' }));
          await trainCtx.audioWorklet.addModule(mod); URL.revokeObjectURL(mod);
          trainNode = new AudioWorkletNode(trainCtx, 'tap', { numberOfInputs:1, numberOfOutputs:1, channelCount:1 });
          trainUsingWorklet = true;
        } catch (e) {
          const node = trainCtx.createScriptProcessor(4096,1,1);
          trainNode = node;
          trainUsingWorklet = false;
          log('warn', 'Training AudioWorklet fell back: ' + (e?.message || e));
        }
      }

      if (trainUsingWorklet) {
        trainNode.port.onmessage = (ev)=> classifyChunk(ev.data, trainCtx.sampleRate, getParams(), modeLabel);
      } else {
        trainNode.onaudioprocess = (e)=> classifyChunk(new Float32Array(e.inputBuffer.getChannelData(0)), trainCtx.sampleRate, getParams(), modeLabel);
      }

      if (!trainSrc) { trainSrc = trainCtx.createMediaElementSource(els.trainAudio); }
      try { trainSrc.disconnect(); } catch {}
      try { trainNode.disconnect(); } catch {}
      trainSrc.connect(trainNode).connect(trainSink);
    }

    function setTrainAudioSrcFromFile(file){
      if (trainBlobUrl) { try { URL.revokeObjectURL(trainBlobUrl); } catch {} }
      trainBlobUrl = URL.createObjectURL(file);
      els.trainAudio.src = trainBlobUrl;
      els.trainAudio.loop = false;
    }

    async function startTrainingOnFile(file) {
      await stopFolderTraining(true);
      await stopAll();
      await ensureTrainGraph('train_file');

      setTrainAudioSrcFromFile(file);
      await ensureAudioTask(Number(els.MAX_RESULTS.value)||25);

      state.mode = 'train_file';
      setPill('training', true);
      setStatus(`Training started (file): ${file.name}`);
      log('ok', `Training started on file: ${file.name}`, `<span class="chip">${(file.size/1024/1024).toFixed(2)} MB</span>`);
      updateToggleButtonsUI();

      els.trainAudio.onended = async () => {
        await stopFilePlayback();
        setStatus('Training clip ended. Click ‚ÄúRecompute Weights‚Äù.');
        setPill('idle', false);
        state.mode='idle';
        clearTopBars();
        updateToggleButtonsUI();
      };

      try { await els.trainAudio.play(); } catch {}
    }

    async function stopFilePlayback(silent = false){
      const wasTraining =
        state.mode === 'train_file' || state.mode === 'train_folder' || !els.trainAudio.paused;
    
      try { els.trainAudio.pause(); } catch {}
      els.trainAudio.onended = null;
      try { if (trainCtx && trainCtx.state !== 'suspended') await trainCtx.suspend(); } catch {}
      clearTopBars();
      setPill('idle', false);
    
      if (wasTraining) state.mode = 'idle';
      if (!silent && wasTraining) setStatus('Training stopped.');
      updateToggleButtonsUI();
    }

    /* ========= Folder training ========= */
    let folderFiles = [];
    let folderIdx = 0;
    let folderActive = false;

    function describeCommonRoot(files){
      const paths = files.map(f => f.webkitRelativePath || f.name);
      if (!paths.length) return '';
      const split = paths.map(p => p.split('/'));
      const minLen = Math.min(...split.map(a=>a.length));
      let i=0; while (i<minLen && split.every(a => a[i]===split[0][i])) i++;
      return split[0].slice(0, Math.max(0, i-1)).join('/') || '(root)';
    }
    function pickAudioFilesFromList(list){
      const arr = Array.from(list || []);
      return arr.filter(f => {
        if (f.type && f.type.startsWith('audio/')) return true;
        return /\.(wav|mp3|m4a|aac|ogg|opus|flac)$/i.test(f.name);
      }).sort((a,b) => {
        const pa = (a.webkitRelativePath || a.name).toLowerCase();
        const pb = (b.webkitRelativePath || b.name).toLowerCase();
        return pa.localeCompare(pb);
      });
    }

    async function startFolderTraining(){
      if (!folderFiles.length) { els.btnChooseFolder.click(); return; }
      await stopAll();
      await ensureTrainGraph('train_folder');
      await ensureAudioTask(Number(els.MAX_RESULTS.value)||25);

      folderActive = true;
      folderIdx = 0;
      state.mode = 'train_folder';
      setPill('training', true);
      setStatus(`Training started (folder): ${folderFiles.length} file(s).`);
      log('ok', `Folder training queued: ${folderFiles.length} file(s) from ‚Äú${describeCommonRoot(folderFiles)}‚Äù.`);
      updateToggleButtonsUI();
      await trainNextFileInFolder();
    }

    async function trainNextFileInFolder(){
      if (!folderActive) return;
      if (folderIdx >= folderFiles.length) {
        await stopFolderTraining(true);
        log('ok', 'Folder training complete.');
        clearTopBars();
        return;
      }
      const f = folderFiles[folderIdx];
      const label = f.webkitRelativePath || f.name;
      log('info', `Starting file ${folderIdx+1}/${folderFiles.length}: ${label}`);

      setTrainAudioSrcFromFile(f);
      els.trainAudio.onended = async () => {
        log('info', `Finished ${folderIdx+1}/${folderFiles.length}`);
        folderIdx++;
        if (folderActive) { await trainNextFileInFolder(); }
      };

      try { await els.trainAudio.play(); } catch (e) { log('err', 'Failed to play file in folder: '+(e?.message||e)); folderIdx++; await trainNextFileInFolder(); }
    }

    async function stopFolderTraining(silent=false){
      folderActive = false;
      folderIdx = 0;
      await stopFilePlayback(true); // <- silent
      setPill('idle', false);
      state.mode = 'idle';
      clearTopBars();
      if (!silent) {
        log('warn','Stopped folder training.');
        setStatus('Training stopped.');
      }
      updateToggleButtonsUI();
    }

    /* ========= Params & UI wiring ========= */
    function getParams(){
      return {
        SR_TARGET: Number(els.SR_TARGET.value)||16000,
        FRAME_LEN_S: Number(els.FRAME_LEN_S.value)||0.975,
        HOP_S: Number(els.HOP_S.value)||0.48,
        MAX_RESULTS: Number(els.MAX_RESULTS.value)||25
      };
    }

    // Detect / Calibrate ‚Äî single toggle buttons
																  
    els.btnDetect.onclick = async () => {
      if (state.mode === 'detect') {
        await stopFolderTraining(true);
        await stopFilePlayback();
        await stopAll();
        setStatus('Detection stopped.');
      } else {
        await stopFolderTraining(true);
        await stopFilePlayback();
        await startInputForMode('detect');
        setPill('idle', false);
      }
      updateToggleButtonsUI();
    };
												
														  

    els.btnCal.onclick = () => {
      if (state.calActive) stopCalibrationEarly();
      else quietCalibrate();
      updateToggleButtonsUI();
    };

    // Training source UI
    function updateTrainingSourceUI(){
      const v = els.TRAIN_SRC.value;
      const showFile   = (v === 'file');
      const showFolder = (v === 'folder');

      els.btnChooseFile.style.display   = showFile ? '' : 'none';
      els.btnChooseFolder.style.display = showFolder ? '' : 'none';

      if (v === 'mic') els.trainInfo.textContent = 'Training from microphone.';
      if (v === 'file') els.trainInfo.textContent = els.fileInp.files?.[0] ? `Selected file: ${els.fileInp.files[0].name}` : 'Choose a file to train.';
      if (v === 'folder') {
        const count = folderFiles.length;
        els.trainInfo.textContent = count ? `${count} audio file(s) selected from ‚Äú${describeCommonRoot(folderFiles)}‚Äù.` : 'Choose a folder with audio files.';
      }
      if (v === 'sender') {
																										 
																		
        const where = (localStorage.getItem('cryInferWhere') || 'sender') === 'receiver'
          ? 'receiver (from streamed audio)'
          : 'sender (scores via data channel)';
        els.trainInfo.textContent = `WebRTC source (Sender). Inference @ ${where}. Room ‚Äú${room}‚Äù.`;
        ensureCoreStarted();
      }
    }
    els.TRAIN_SRC.addEventListener('change', updateTrainingSourceUI);
    updateTrainingSourceUI();

    // Choose buttons
    els.btnChooseFile.onclick = () => els.fileInp.click();
    els.fileInp.onchange = () => {
      const f = els.fileInp.files?.[0];
      els.trainInfo.textContent = f ? `Selected file: ${f.name}` : 'Choose a file to train.';
      log('info', els.trainInfo.textContent);
    };

    els.btnChooseFolder.onclick = () => els.folderInp.click();
    els.folderInp.onchange = () => {
      folderFiles = pickAudioFilesFromList(els.folderInp.files);
      const root = describeCommonRoot(folderFiles);
      els.trainInfo.textContent = folderFiles.length
        ? `${folderFiles.length} audio file(s) selected from ‚Äú${root}‚Äù.`
        : 'No audio files found in the chosen folder.';
      log('info', els.trainInfo.textContent);
    };

    // Training single toggle
    els.btnTrain.onclick = async () => {
      const src = els.TRAIN_SRC.value;
      const trainingActive = (state.mode === 'train' || state.mode === 'train_file' || state.mode === 'train_folder');

      if (trainingActive) {
        if (src === 'mic') await stopAll();
        else if (src === 'file') await stopFilePlayback();
        else if (src === 'folder') await stopFolderTraining();
        else if (src === 'sender') { await stopAll(); }
        setStatus('Training stopped');
        updateToggleButtonsUI();
        return;
      }

      // Start training
      if (src === 'mic') {
        await startMic('train');
      } else if (src === 'file') {
        const f = els.fileInp.files?.[0];
        if (!f) { els.btnChooseFile.click(); setStatus('Pick an audio file first'); return; }
        await startTrainingOnFile(f);
      } else if (src === 'folder') {
        if (!folderFiles.length) { els.btnChooseFolder.click(); setStatus('Pick a folder first'); return; }
        await startFolderTraining();
      } else if (src === 'sender') {
        ensureCoreStarted();
        state.mode = 'train';
        setPill('training', true);
        setStatus('Training started (sender).');
																				 
        if (wrtc.where === 'receiver' && wrtc.stream) {
          await startRemoteAudioTap('train');
        }
      }
      updateToggleButtonsUI();
											
									  
										 
														
															
													 
									
    };

    // Recompute / Clear / Export
    els.btnRecompute.onclick = () => {
      const m = loadModel();
      m.K = Number(els.TOP_K.value)||m.K||6;
      m.kPrior = Number(els.K_PRIOR.value)||m.kPrior||50;
      m.halfLifeSec = Number(els.HALF_LIFE_S.value)||m.halfLifeSec||3600;
      const w = recomputeWeights(m);
      setWeightsChart(state.barSavedW, w);
      setStatus('Weights recomputed. Model updated.');
    };
    els.btnClear.onclick = () => {
      const name = getModelName();
      clearModel();
      setWeightsChart(state.barDynW, {});
      setWeightsChart(state.barSavedW, {});
      setupChart();
      clearTopBars();
      setStatus(`Model ‚Äú${name}‚Äù cleared.`);
      refreshModelSelect(getModelName());
    };
    els.btnExport.onclick = () => {
      const key = MODEL_KEY();
      const blob = new Blob([localStorage.getItem(key) || '{}'], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `cryModel_${getModelName()}.json`; a.click();
      URL.revokeObjectURL(a.href);
      log('ok',`Exported cryModel_${getModelName()}.json`);
    };

    /* Dropdown behavior */
    els.MODEL_SELECT.addEventListener('change', () => {
      const v = els.MODEL_SELECT.value;
      if (v === NEW_MODEL_VALUE) {
        const name = (prompt('New model name:', '').trim() || '').replace(/[^\w \-().,]/g,'').trim();
        if (!name) { refreshModelSelect(getModelName()); return; }
        const exists = listModelNames().includes(name);
        setModelName(name);
        if (!exists) { const m = loadModel(); saveModel(m); log('ok', `Created model ‚Äú${name}‚Äù.`); }
        else { log('info', `Switched to existing model ‚Äú${name}‚Äù.`); }
        refreshModelSelect(name);
        const m2 = loadModel();
        setWeightsChart(state.barSavedW, m2.weights || {});
        setWeightsChart(state.barDynW, computeWeightsPreview(m2));
        const calib2 = JSON.parse(localStorage.getItem(CALIB_KEY()) || 'null');
        if (calib2) { state.thrOn = calib2.thr_on; state.thrOff = calib2.thr_off; setThrUI(); log('ok', `Loaded calibration for ‚Äú${name}‚Äù.`, `<div class="log-code">${JSON.stringify(calib2,null,2)}</div>`); }
        const ignoreSaved = localStorage.getItem(IGNORE_KEY()); if (ignoreSaved) els.IGNORE_CLASSES.value = ignoreSaved;
        const penaltySaved = localStorage.getItem(PENALTY_KEY()); if (penaltySaved) els.PENALTY_MAP.value = penaltySaved;
        setStatus(`Active model set to ‚Äú${name}‚Äù.`);
      } else {
        setModelName(v);
        const m = loadModel();
        setWeightsChart(state.barSavedW, m.weights || {});
        setWeightsChart(state.barDynW, computeWeightsPreview(m));
        const calib = JSON.parse(localStorage.getItem(CALIB_KEY()) || 'null');
        if (calib) { state.thrOn = calib.thr_on; state.thrOff = calib.thr_off; setThrUI(); log('ok', `Loaded calibration for ‚Äú${v}‚Äù.`, `<div class="log-code">${JSON.stringify(calib,null,2)}</div>`); }
        const ignoreSaved = localStorage.getItem(IGNORE_KEY()); if (ignoreSaved) els.IGNORE_CLASSES.value = ignoreSaved;
        const penaltySaved = localStorage.getItem(PENALTY_KEY()); if (penaltySaved) els.PENALTY_MAP.value = penaltySaved;
        setStatus(`Loaded model ‚Äú${v}‚Äù.`);
      }
    });

    // Persist knobs + update preview/saved charts
    ['TOP_K','K_PRIOR','HALF_LIFE_S'].forEach(id => {
      document.getElementById(id).addEventListener('change', () => {
        const m = loadModel();
        if (id==='TOP_K') m.K = Number(els.TOP_K.value)||m.K;
        if (id==='K_PRIOR') m.kPrior = Number(els.K_PRIOR.value)||m.kPrior;
        if (id==='HALF_LIFE_S') m.halfLifeSec = Number(els.HALF_LIFE_S.value)||m.halfLifeSec;
        saveModel(m);
        log('info', `Param updated: ${id} = ${document.getElementById(id).value} (saved in ‚Äú${getModelName()}‚Äù)`);
        setWeightsChart(state.barDynW, computeWeightsPreview(m));
        setWeightsChart(state.barSavedW, m.weights || {});
      });
    });

    // If hop changes, recompute chart window capacity immediately
    document.getElementById('HOP_S').addEventListener('change', () => {
      state.hopSec = Number(els.HOP_S.value)||0.48;
      setupChart();
    });

    // Chart window control
    els.CHART_WINDOW_S.addEventListener('change', () => {
      const v = Math.max(5, Number(els.CHART_WINDOW_S.value) || 30);
      els.CHART_WINDOW_S.value = String(v);
      state.chartWindowSec = v;
      setupChart();
      log('info', `Chart window set to ${v}s`);
    });

    // Persist ignore/penalty immediately
    ['IGNORE_CLASSES','PENALTY_MAP'].forEach(id=>{
      const el = document.getElementById(id); if (!el) return;
      const save = () => {
        const key = (id==='IGNORE_CLASSES') ? IGNORE_KEY() : PENALTY_KEY();
        localStorage.setItem(key, el.value);
        log('info', `${id==='IGNORE_CLASSES'?'Ignore classes':'Penalty map'} updated for ‚Äú${getModelName()}‚Äù.`);
        if (state.mode==='idle') clearTopBars();
      };
      el.addEventListener('change', save);
      el.addEventListener('blur', save);
    });

    /* ========= Bars setup ========= */
    function setupAllBars(){
      setupBars();
      const m = loadModel();
      setWeightsChart(state.barSavedW, m.weights || {});
      setWeightsChart(state.barDynW, computeWeightsPreview(m));
    }

    /* ========= NEW: WebRTC integration ========= *//* ========= NEW: WebRTC integration (robust DC wiring) ========= */
    function ensureCoreStarted(){
      if (wrtc.core) return;
    
      // One function to wire handlers no matter who created the DC
      function wireDC(ch){
        if (!ch) return;
        // Avoid double-wiring the same channel
        if (wrtc.dc && wrtc.dc === ch) return;
        wrtc.dc = ch;
    
        ch.onopen  = () => {
          log('ok','[RTC] DC open');
          try { ch.send(JSON.stringify({ type: 'need-modes' })); } catch {}
        };
        ch.onclose = () => log('warn','[RTC] DC close');
        ch.onerror = (e) => log('err', `[RTC] DC error: ${e?.message||e}`);
    
        ch.onmessage = (ev) => {
          let msg; try { msg = JSON.parse(ev.data); } catch { return; }
          if (!msg || !msg.type) return;
    
          if (msg.type === 'audio-mode') {
            // Sender tells us whether to stream audio or push scores
            wrtc.audioEnabled = !!msg.enabled;
            wrtc.where        = msg.where || 'sender';
            if (msg.where) setInferWhere(msg.where); // persist who runs inference
            setStatus('Connected to sender');
            log('info', `[RTC] audio-mode: enabled=${wrtc.audioEnabled} where=${wrtc.where}`);
    
            if (!wrtc.audioEnabled) {
              stopRemoteAudioTap();
            } else if (wrtc.where === 'receiver' && wrtc.stream && state.mode !== 'idle') {
              // If we're already training/detecting and sender wants us to classify
              startRemoteAudioTap(state.mode);
            }
    
          } else if (msg.type === 'ai-modes' && msg.audio) {
            // Same thing but nested under ai-modes
            wrtc.audioEnabled = !!msg.audio.enabled;
            wrtc.where        = msg.audio.where || 'sender';
            if (msg.audio.where) setInferWhere(msg.audio.where);
            setStatus('Connected to sender');
            log('info', `[RTC] ai-modes: enabled=${wrtc.audioEnabled} where=${wrtc.where}`);
    
            if (!wrtc.audioEnabled) {
              stopRemoteAudioTap();
            } else if (wrtc.where === 'receiver' && wrtc.stream && state.mode !== 'idle') {
              startRemoteAudioTap(state.mode);
            }
    
          } else if (msg.type === 'audio') {
            // Sender is pushing categories (inference @ sender)
            setInferWhere('sender'); // keep UI suffix consistent
            if (els.TRAIN_SRC.value === 'sender') {
              const categories = (msg.categories || []).map(c => ({
                categoryName: (c.displayName || c.categoryName || '').trim(),
                score: c.score || 0
              }));
              const mode = state.mode; // 'train' or 'detect'
              if (mode === 'train' || mode === 'detect') {
                setStatus('Connected to sender');
                onCategories(categories, mode);
                // noteScore(); // (optional watchdog, see below)
              }
            }
          }
        };
      }
    
      wrtc.core = new ReceiverCore({
        wsEndpoint: WS_ENDPOINT,
        room,
        onStatus: (msg) => { log('info', `[RTC] ${msg}`); },
        onStream: (stream) => {
          if (EL('remote').srcObject !== stream) {
            EL('remote').srcObject = stream;
          }
          wrtc.stream = stream;
          log('ok', `[RTC] Remote stream: tracks=${stream.getTracks().map(t=>t.kind).join(',')}`);
          if (state.mode !== 'idle' && wrtc.audioEnabled && wrtc.where === 'receiver') {
            startRemoteAudioTap(state.mode).catch(()=>{});
          }
        },
        onIceState: (s) => log('info', `[RTC] ICE: ${s}`),
    
        // We create a DC ‚Üí wire it
        onCreatePC: (pc) => {
          const ch = pc.createDataChannel('pose');
          wireDC(ch);
        },
    
        // Sender creates a DC ‚Üí wire it too
        onDataChannel: (e) => {
          log('info', `[RTC] inbound DC: ${e.channel?.label}`);
          wireDC(e.channel);
        },
    
        onBye: () => log('warn', '[RTC] bye')
      });
    
      wrtc.core.start()
        .then(()=>{ wrtc.connected = true; log('ok', `[RTC] Connected to room ‚Äú${room}‚Äù.`); })
        .catch(e => log('err', `[RTC] start error: ${e?.message||e}`));
    }
    
    /* --- Optional: quick ‚Äúno scores‚Äù watchdog (uncomment to use) --- */
    // let lastScoreTs = 0;
    // function noteScore(){ lastScoreTs = performance.now(); }
    // setInterval(() => {
    //   if (state.mode !== 'detect' && state.mode !== 'train') return;
    //   if (els.TRAIN_SRC.value !== 'sender') return;
    //   if ((performance.now() - lastScoreTs) > 5000) {
    //     log('warn','No score frames in >5s. If the sender is running, it may be using a different room or not sending scores.');
    //   }
    // }, 2500);


    async function startRemoteAudioTap(mode){
      if (!wrtc.stream) { log('warn','[RTC] No remote stream yet.'); return; }
      await stopRemoteAudioTap();
      const ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive' });
      wrtc.ctx = ctx; await ctx.resume().catch(()=>{});
      const src = ctx.createMediaStreamSource(wrtc.stream);
      const sink = ctx.createGain(); sink.gain.value = 0; sink.connect(ctx.destination);
      wrtc.src = src; wrtc.sink = sink;

      try {
        const workletURL = URL.createObjectURL(new Blob([`
          class Tap extends AudioWorkletProcessor {
            process(inputs) {
              const i = inputs[0]; if (i && i[0]) this.port.postMessage(i[0].slice(0)); return true;
            }
          }
          registerProcessor('tap', Tap);
        `], { type: 'application/javascript' }));
        await ctx.audioWorklet.addModule(workletURL); URL.revokeObjectURL(workletURL);
        const node = new AudioWorkletNode(ctx, 'tap', { numberOfInputs:1, numberOfOutputs:1, channelCount:1 });
        node.port.onmessage = (ev)=> classifyChunk(ev.data, ctx.sampleRate, getParams(), mode);
        src.connect(node).connect(sink);
        wrtc.node = node;
        log('info','[RTC] Remote tap (worklet) active.');
      } catch (e) {
        const node = ctx.createScriptProcessor(4096,1,1);
        node.onaudioprocess = (ev)=> classifyChunk(new Float32Array(ev.inputBuffer.getChannelData(0)), ctx.sampleRate, getParams(), mode);
        src.connect(node).connect(sink);
        wrtc.node = node;
        log('warn','[RTC] Worklet failed; using ScriptProcessor.');
      }
      state.running = true;
      state.mode = mode;
      setupChart();
      if (mode === 'train') setStatus('Training started (sender audio ‚Üí local inference).');
      if (mode === 'detect' && !state.calActive) setStatus('Detection started (sender audio ‚Üí local inference).');
      updateToggleButtonsUI();
    }

    async function stopRemoteAudioTap(){
      try { wrtc.node?.disconnect?.(); } catch {}
      try { wrtc.src?.disconnect?.(); } catch {}
      try { wrtc.sink?.disconnect?.(); } catch {}
      try { wrtc.ctx && wrtc.ctx.state!=='closed' && wrtc.ctx.close(); } catch {}
      wrtc.node = null; wrtc.src = null; wrtc.sink = null; wrtc.ctx = null;
    }

    /* ========= Mode selection helpers ========= */
    async function startInputForMode(mode){
      const src = els.TRAIN_SRC.value;
      if (src === 'mic') return startMic(mode);
      if (src === 'sender') {
        ensureCoreStarted();
        // If sender wants receiver to classify, start tap:
        if (wrtc.where === 'receiver') await startRemoteAudioTap(mode);
        state.mode = mode;
        if (mode === 'detect' && !state.calActive) setStatus('Detection started (sender).');
        if (mode === 'train') setStatus('Training started (sender).');
        updateToggleButtonsUI();
        return;
      }
      // file/folder not applicable here
      setStatus('Select Mic or Sender for this action.');
    }

    async function startDetectBasedOnSource(){
      await stopFolderTraining(true);
      await stopFilePlayback();
      await startInputForMode('detect');
      setPill('idle', false);
      updateToggleButtonsUI();
    }

    /* ========= Boot ========= */
    (function boot(){
      const active = localStorage.getItem('cryActiveModelName') || 'default';
      refreshModelSelect(active);
      setModelName(active);

      setupAllBars();
      els.chart.getContext && setupChart();

      const calib = JSON.parse(localStorage.getItem(CALIB_KEY()) || 'null');
      if (calib) {
        state.thrOn=calib.thr_on; state.thrOff=calib.thr_off;
        log('ok',`Loaded calibration for ‚Äú${getModelName()}‚Äù.`, `<div class="log-code">${JSON.stringify(calib,null,2)}</div>`);
      } else {
        const offDelta = Number(els.ALERT_OFF_DELTA.value) || 0.10;
        state.thrOn = 0.35; state.thrOff = Math.max(0, state.thrOn - offDelta);
      }
      setThrUI();
      enableThrSliders(true);

      const ignoreSaved = localStorage.getItem(IGNORE_KEY()); if (ignoreSaved) els.IGNORE_CLASSES.value = ignoreSaved;
      const penaltySaved = localStorage.getItem(PENALTY_KEY()); if (penaltySaved) els.PENALTY_MAP.value = penaltySaved;

      hideLiveBars();
      setStatus('Ready. Train (mic/file/folder/sender) ‚Üí Recompute Weights ‚Üí Quiet Calibrate ‚Üí Start detection.');
      updateToggleButtonsUI();
    })();
  </script>

  <!-- analytics -->
  <script type="module">
    import { installAnalytics } from '/hungryface/shared/analytics.js';
    window.analytics = installAnalytics({ feature: 'receiver-audio-training' });
    // Later: window.analytics.event('audio_training_opened');
  </script>
	
</body>
</html>
